{"version":3,"file":"index.cjs.js","sources":["../src/IndexBuilder.ts","../src/runPeriodically.ts","../src/Scheduler.ts","../src/indexing/BatchSearchEngineIndexer.ts","../src/indexing/DecoratorBase.ts","../src/engines/LunrSearchEngineIndexer.ts","../src/engines/LunrSearchEngine.ts","../src/test-utils/TestPipeline.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DocumentCollatorFactory,\n  DocumentDecoratorFactory,\n  DocumentTypeInfo,\n  SearchEngine,\n} from '@backstage/plugin-search-common';\nimport { Transform, pipeline } from 'stream';\nimport { Logger } from 'winston';\nimport { Scheduler } from './index';\nimport {\n  IndexBuilderOptions,\n  RegisterCollatorParameters,\n  RegisterDecoratorParameters,\n} from './types';\n\ninterface CollatorEnvelope {\n  factory: DocumentCollatorFactory;\n  refreshInterval: number;\n}\n\n/**\n * @beta\n */\nexport class IndexBuilder {\n  private collators: Record<string, CollatorEnvelope>;\n  private decorators: Record<string, DocumentDecoratorFactory[]>;\n  private documentTypes: Record<string, DocumentTypeInfo>;\n  private searchEngine: SearchEngine;\n  private logger: Logger;\n\n  constructor({ logger, searchEngine }: IndexBuilderOptions) {\n    this.collators = {};\n    this.decorators = {};\n    this.documentTypes = {};\n    this.logger = logger;\n    this.searchEngine = searchEngine;\n  }\n\n  getSearchEngine(): SearchEngine {\n    return this.searchEngine;\n  }\n\n  getDocumentTypes(): Record<string, DocumentTypeInfo> {\n    return this.documentTypes;\n  }\n\n  /**\n   * Makes the index builder aware of a collator that should be executed at the\n   * given refresh interval.\n   */\n  addCollator({\n    factory,\n    defaultRefreshIntervalSeconds,\n  }: RegisterCollatorParameters): void {\n    this.logger.info(\n      `Added ${factory.constructor.name} collator factory for type ${factory.type}`,\n    );\n    this.collators[factory.type] = {\n      refreshInterval: defaultRefreshIntervalSeconds,\n      factory,\n    };\n    this.documentTypes[factory.type] = {\n      visibilityPermission: factory.visibilityPermission,\n    };\n  }\n\n  /**\n   * Makes the index builder aware of a decorator. If no types are provided on\n   * the decorator, it will be applied to documents from all known collators,\n   * otherwise it will only be applied to documents of the given types.\n   */\n  addDecorator({ factory }: RegisterDecoratorParameters): void {\n    const types = factory.types || ['*'];\n    this.logger.info(\n      `Added decorator ${factory.constructor.name} to types ${types.join(\n        ', ',\n      )}`,\n    );\n    types.forEach(type => {\n      if (this.decorators.hasOwnProperty(type)) {\n        this.decorators[type].push(factory);\n      } else {\n        this.decorators[type] = [factory];\n      }\n    });\n  }\n\n  /**\n   * Compiles collators and decorators into tasks, which are added to a\n   * scheduler returned to the caller.\n   */\n  async build(): Promise<{ scheduler: Scheduler }> {\n    const scheduler = new Scheduler({ logger: this.logger });\n\n    Object.keys(this.collators).forEach(type => {\n      scheduler.addToSchedule(async () => {\n        // Instantiate the collator.\n        const collator = await this.collators[type].factory.getCollator();\n        this.logger.info(\n          `Collating documents for ${type} via ${this.collators[type].factory.constructor.name}`,\n        );\n\n        // Instantiate all relevant decorators.\n        const decorators: Transform[] = await Promise.all(\n          (this.decorators['*'] || [])\n            .concat(this.decorators[type] || [])\n            .map(async factory => {\n              const decorator = await factory.getDecorator();\n              this.logger.info(\n                `Attached decorator via ${factory.constructor.name} to ${type} index pipeline.`,\n              );\n              return decorator;\n            }),\n        );\n\n        // Instantiate the indexer.\n        const indexer = await this.searchEngine.getIndexer(type);\n\n        // Compose collator/decorators/indexer into a pipeline\n        return new Promise<void>(done => {\n          pipeline([collator, ...decorators, indexer], error => {\n            if (error) {\n              this.logger.error(\n                `Collating documents for ${type} failed: ${error}`,\n              );\n            } else {\n              this.logger.info(`Collating documents for ${type} succeeded`);\n            }\n\n            // Signal index pipeline completion!\n            done();\n          });\n        });\n      }, this.collators[type].refreshInterval * 1000);\n    });\n\n    return {\n      scheduler,\n    };\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Runs a function repeatedly, with a fixed wait between invocations.\n *\n * Supports async functions, and silently ignores exceptions and rejections.\n *\n * @param fn - The function to run. May return a Promise.\n * @param delayMs - The delay between a completed function invocation and the\n *                next.\n * @returns A function that, when called, stops the invocation loop.\n */\nexport function runPeriodically(fn: () => any, delayMs: number): () => void {\n  let cancel: () => void;\n  let cancelled = false;\n  const cancellationPromise = new Promise<void>(resolve => {\n    cancel = () => {\n      resolve();\n      cancelled = true;\n    };\n  });\n\n  const startRefresh = async () => {\n    while (!cancelled) {\n      try {\n        await fn();\n      } catch {\n        // ignore intentionally\n      }\n\n      await Promise.race([\n        new Promise(resolve => setTimeout(resolve, delayMs)),\n        cancellationPromise,\n      ]);\n    }\n  };\n  startRefresh();\n\n  return cancel!;\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Logger } from 'winston';\nimport { runPeriodically } from './runPeriodically';\n\ntype TaskEnvelope = {\n  task: Function;\n  interval: number;\n};\n\n/**\n * TODO: coordination, error handling\n */\n\n/**\n * @beta\n */\nexport class Scheduler {\n  private logger: Logger;\n  private schedule: TaskEnvelope[];\n  private runningTasks: Function[] = [];\n\n  constructor({ logger }: { logger: Logger }) {\n    this.logger = logger;\n    this.schedule = [];\n  }\n\n  /**\n   * Adds each task and interval to the schedule.\n   * When running the tasks, the scheduler waits at least for the time specified\n   * in the interval once the task was completed, before running it again.\n   */\n  addToSchedule(task: Function, interval: number) {\n    if (this.runningTasks.length) {\n      throw new Error(\n        'Cannot add task to schedule that has already been started.',\n      );\n    }\n    this.schedule.push({ task, interval });\n  }\n\n  /**\n   * Starts the scheduling process for each task\n   */\n  start() {\n    this.logger.info('Starting all scheduled search tasks.');\n    this.schedule.forEach(({ task, interval }) => {\n      this.runningTasks.push(runPeriodically(() => task(), interval));\n    });\n  }\n\n  /**\n   * Stop all scheduled tasks.\n   */\n  stop() {\n    this.logger.info('Stopping all scheduled search tasks.');\n    this.runningTasks.forEach(cancel => {\n      cancel();\n    });\n    this.runningTasks = [];\n  }\n}\n","/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assertError } from '@backstage/errors';\nimport { IndexableDocument } from '@backstage/plugin-search-common';\nimport { Writable } from 'stream';\n\n/**\n * @beta\n */\nexport type BatchSearchEngineOptions = {\n  batchSize: number;\n};\n\n/**\n * Base class encapsulating batch-based stream processing. Useful as a base\n * class for search engine indexers.\n * @beta\n */\nexport abstract class BatchSearchEngineIndexer extends Writable {\n  private batchSize: number;\n  private currentBatch: IndexableDocument[] = [];\n  private initialized: Promise<undefined | Error>;\n\n  constructor(options: BatchSearchEngineOptions) {\n    super({ objectMode: true });\n    this.batchSize = options.batchSize;\n\n    // @todo Once node v15 is minimum, convert to _construct implementation.\n    this.initialized = new Promise(done => {\n      // Necessary to allow concrete implementation classes to construct\n      // themselves before calling their initialize() methods.\n      setImmediate(async () => {\n        try {\n          await this.initialize();\n          done(undefined);\n        } catch (e) {\n          assertError(e);\n          done(e);\n        }\n      });\n    });\n  }\n\n  /**\n   * Receives an array of indexable documents (of size this.batchSize) which\n   * should be written to the search engine. This method won't be called again\n   * at least until it resolves.\n   */\n  public abstract index(documents: IndexableDocument[]): Promise<void>;\n\n  /**\n   * Any asynchronous setup tasks can be performed here.\n   */\n  public abstract initialize(): Promise<void>;\n\n  /**\n   * Any asynchronous teardown tasks can be performed here.\n   */\n  public abstract finalize(): Promise<void>;\n\n  /**\n   * Encapsulates batch stream write logic.\n   * @internal\n   */\n  async _write(\n    doc: IndexableDocument,\n    _e: any,\n    done: (error?: Error | null) => void,\n  ) {\n    // Wait for init before proceeding. Throw error if initialization failed.\n    const maybeError = await this.initialized;\n    if (maybeError) {\n      done(maybeError);\n      return;\n    }\n\n    this.currentBatch.push(doc);\n    if (this.currentBatch.length < this.batchSize) {\n      done();\n      return;\n    }\n\n    try {\n      await this.index(this.currentBatch);\n      this.currentBatch = [];\n      done();\n    } catch (e) {\n      assertError(e);\n      done(e);\n    }\n  }\n\n  /**\n   * Encapsulates finalization and final error handling logic.\n   * @internal\n   */\n  async _final(done: (error?: Error | null) => void) {\n    try {\n      // Index any remaining documents.\n      if (this.currentBatch.length) {\n        await this.index(this.currentBatch);\n        this.currentBatch = [];\n      }\n      await this.finalize();\n      done();\n    } catch (e) {\n      assertError(e);\n      done(e);\n    }\n  }\n}\n","/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assertError } from '@backstage/errors';\nimport { IndexableDocument } from '@backstage/plugin-search-common';\nimport { Transform } from 'stream';\n\n/**\n * Base class encapsulating simple async transformations. Useful as a base\n * class for Backstage search decorators.\n * @beta\n */\nexport abstract class DecoratorBase extends Transform {\n  private initialized: Promise<undefined | Error>;\n\n  constructor() {\n    super({ objectMode: true });\n\n    // @todo Once node v15 is minimum, convert to _construct implementation.\n    this.initialized = new Promise(done => {\n      // Necessary to allow concrete implementation classes to construct\n      // themselves before calling their initialize() methods.\n      setImmediate(async () => {\n        try {\n          await this.initialize();\n          done(undefined);\n        } catch (e) {\n          assertError(e);\n          done(e);\n        }\n      });\n    });\n  }\n\n  /**\n   * Any asynchronous setup tasks can be performed here.\n   */\n  public abstract initialize(): Promise<void>;\n\n  /**\n   * Receives a single indexable document. In your decorate method, you can:\n   *\n   * - Resolve `undefined` to indicate the record should be omitted.\n   * - Resolve a single modified document, which could contain new fields,\n   *   edited fields, or removed fields.\n   * - Resolve an array of indexable documents, if the purpose if the decorator\n   *   is to convert one document into multiple derivative documents.\n   */\n  public abstract decorate(\n    document: IndexableDocument,\n  ): Promise<IndexableDocument | IndexableDocument[] | undefined>;\n\n  /**\n   * Any asynchronous teardown tasks can be performed here.\n   */\n  public abstract finalize(): Promise<void>;\n\n  /**\n   * Encapsulates simple transform stream logic.\n   * @internal\n   */\n  async _transform(\n    document: IndexableDocument,\n    _: any,\n    done: (error?: Error | null) => void,\n  ) {\n    // Wait for init before proceeding. Throw error if initialization failed.\n    const maybeError = await this.initialized;\n    if (maybeError) {\n      done(maybeError);\n      return;\n    }\n\n    try {\n      const decorated = await this.decorate(document);\n\n      // If undefined was returned, omit the record and move on.\n      if (decorated === undefined) {\n        done();\n        return;\n      }\n\n      // If an array of documents was given, push them all.\n      if (Array.isArray(decorated)) {\n        decorated.forEach(doc => {\n          this.push(doc);\n        });\n        done();\n        return;\n      }\n\n      // Otherwise, just push the decorated document.\n      this.push(decorated);\n      done();\n    } catch (e) {\n      assertError(e);\n      done(e);\n    }\n  }\n\n  /**\n   * Encapsulates finalization and final error handling logic.\n   * @internal\n   */\n  async _final(done: (error?: Error | null) => void) {\n    try {\n      await this.finalize();\n      done();\n    } catch (e) {\n      assertError(e);\n      done(e);\n    }\n  }\n}\n","/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IndexableDocument } from '@backstage/plugin-search-common';\nimport lunr from 'lunr';\nimport { BatchSearchEngineIndexer } from '../indexing';\n\n/**\n * @beta\n */\nexport class LunrSearchEngineIndexer extends BatchSearchEngineIndexer {\n  private schemaInitialized = false;\n  private builder: lunr.Builder;\n  private docStore: Record<string, IndexableDocument> = {};\n\n  constructor() {\n    super({ batchSize: 100 });\n\n    this.builder = new lunr.Builder();\n    this.builder.pipeline.add(lunr.trimmer, lunr.stopWordFilter, lunr.stemmer);\n    this.builder.searchPipeline.add(lunr.stemmer);\n  }\n\n  // No async initialization required.\n  async initialize(): Promise<void> {}\n  async finalize(): Promise<void> {}\n\n  async index(documents: IndexableDocument[]): Promise<void> {\n    if (!this.schemaInitialized) {\n      // Make this lunr index aware of all relevant fields.\n      Object.keys(documents[0]).forEach(field => {\n        this.builder.field(field);\n      });\n\n      // Set \"location\" field as reference field\n      this.builder.ref('location');\n\n      this.schemaInitialized = true;\n    }\n\n    documents.forEach(document => {\n      // Add document to Lunar index\n      this.builder.add(document);\n\n      // Store documents in memory to be able to look up document using the ref during query time\n      // This is not how you should implement your SearchEngine implementation! Do not copy!\n      this.docStore[document.location] = document;\n    });\n  }\n\n  buildIndex() {\n    return this.builder.build();\n  }\n\n  getDocumentStore() {\n    return this.docStore;\n  }\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  IndexableDocument,\n  SearchQuery,\n  SearchResultSet,\n  QueryTranslator,\n  SearchEngine,\n} from '@backstage/plugin-search-common';\nimport lunr from 'lunr';\nimport { Logger } from 'winston';\nimport { LunrSearchEngineIndexer } from './LunrSearchEngineIndexer';\n\n/**\n * @beta\n */\nexport type ConcreteLunrQuery = {\n  lunrQueryBuilder: lunr.Index.QueryBuilder;\n  documentTypes?: string[];\n  pageSize: number;\n};\n\ntype LunrResultEnvelope = {\n  result: lunr.Index.Result;\n  type: string;\n};\n\n/**\n * @beta\n */\nexport type LunrQueryTranslator = (query: SearchQuery) => ConcreteLunrQuery;\n\n/**\n * @beta\n */\nexport class LunrSearchEngine implements SearchEngine {\n  protected lunrIndices: Record<string, lunr.Index> = {};\n  protected docStore: Record<string, IndexableDocument>;\n  protected logger: Logger;\n\n  constructor({ logger }: { logger: Logger }) {\n    this.logger = logger;\n    this.docStore = {};\n  }\n\n  protected translator: QueryTranslator = ({\n    term,\n    filters,\n    types,\n  }: SearchQuery): ConcreteLunrQuery => {\n    const pageSize = 25;\n\n    return {\n      lunrQueryBuilder: q => {\n        const termToken = lunr.tokenizer(term);\n\n        // Support for typeahead seach is based on https://github.com/olivernn/lunr.js/issues/256#issuecomment-295407852\n        // look for an exact match and apply a large positive boost\n        q.term(termToken, {\n          usePipeline: true,\n          boost: 100,\n        });\n        // look for terms that match the beginning of this term and apply a\n        // medium boost\n        q.term(termToken, {\n          usePipeline: false,\n          boost: 10,\n          wildcard: lunr.Query.wildcard.TRAILING,\n        });\n        // look for terms that match with an edit distance of 2 and apply a\n        // small boost\n        q.term(termToken, {\n          usePipeline: false,\n          editDistance: 2,\n          boost: 1,\n        });\n\n        if (filters) {\n          Object.entries(filters).forEach(([field, fieldValue]) => {\n            if (!q.allFields.includes(field)) {\n              // Throw for unknown field, as this will be a non match\n              throw new Error(`unrecognised field ${field}`);\n            }\n            // Arrays are poorly supported, but we can make it better for single-item arrays,\n            // which should be a common case\n            const value =\n              Array.isArray(fieldValue) && fieldValue.length === 1\n                ? fieldValue[0]\n                : fieldValue;\n\n            // Require that the given field has the given value\n            if (['string', 'number', 'boolean'].includes(typeof value)) {\n              q.term(lunr.tokenizer(value?.toString()), {\n                presence: lunr.Query.presence.REQUIRED,\n                fields: [field],\n              });\n            } else if (Array.isArray(value)) {\n              // Illustrate how multi-value filters could work.\n              // But warn that Lurn supports this poorly.\n              this.logger.warn(\n                `Non-scalar filter value used for field ${field}. Consider using a different Search Engine for better results.`,\n              );\n              q.term(lunr.tokenizer(value), {\n                presence: lunr.Query.presence.OPTIONAL,\n                fields: [field],\n              });\n            } else {\n              // Log a warning or something about unknown filter value\n              this.logger.warn(`Unknown filter type used on field ${field}`);\n            }\n          });\n        }\n      },\n      documentTypes: types,\n      pageSize,\n    };\n  };\n\n  setTranslator(translator: LunrQueryTranslator) {\n    this.translator = translator;\n  }\n\n  async getIndexer(type: string) {\n    const indexer = new LunrSearchEngineIndexer();\n\n    indexer.on('close', () => {\n      // Once the stream is closed, build the index and store the documents in\n      // memory for later retrieval.\n      this.lunrIndices[type] = indexer.buildIndex();\n      this.docStore = { ...this.docStore, ...indexer.getDocumentStore() };\n    });\n\n    return indexer;\n  }\n\n  async query(query: SearchQuery): Promise<SearchResultSet> {\n    const { lunrQueryBuilder, documentTypes, pageSize } = this.translator(\n      query,\n    ) as ConcreteLunrQuery;\n\n    const results: LunrResultEnvelope[] = [];\n\n    // Iterate over the filtered list of this.lunrIndex keys.\n    Object.keys(this.lunrIndices)\n      .filter(type => !documentTypes || documentTypes.includes(type))\n      .forEach(type => {\n        try {\n          results.push(\n            ...this.lunrIndices[type].query(lunrQueryBuilder).map(result => {\n              return {\n                result: result,\n                type: type,\n              };\n            }),\n          );\n        } catch (err) {\n          // if a field does not exist on a index, we can see that as a no-match\n          if (\n            err instanceof Error &&\n            err.message.startsWith('unrecognised field')\n          ) {\n            return;\n          }\n          throw err;\n        }\n      });\n\n    // Sort results.\n    results.sort((doc1, doc2) => {\n      return doc2.result.score - doc1.result.score;\n    });\n\n    // Perform paging\n    const { page } = decodePageCursor(query.pageCursor);\n    const offset = page * pageSize;\n    const hasPreviousPage = page > 0;\n    const hasNextPage = results.length > offset + pageSize;\n    const nextPageCursor = hasNextPage\n      ? encodePageCursor({ page: page + 1 })\n      : undefined;\n    const previousPageCursor = hasPreviousPage\n      ? encodePageCursor({ page: page - 1 })\n      : undefined;\n\n    // Translate results into SearchResultSet\n    const realResultSet: SearchResultSet = {\n      results: results.slice(offset, offset + pageSize).map(d => {\n        return { type: d.type, document: this.docStore[d.result.ref] };\n      }),\n      nextPageCursor,\n      previousPageCursor,\n    };\n\n    return realResultSet;\n  }\n}\n\nexport function decodePageCursor(pageCursor?: string): { page: number } {\n  if (!pageCursor) {\n    return { page: 0 };\n  }\n\n  return {\n    page: Number(Buffer.from(pageCursor, 'base64').toString('utf-8')),\n  };\n}\n\nexport function encodePageCursor({ page }: { page: number }): string {\n  return Buffer.from(`${page}`, 'utf-8').toString('base64');\n}\n","/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IndexableDocument } from '@backstage/plugin-search-common';\nimport { pipeline, Readable, Transform, Writable } from 'stream';\n\n/**\n * Object resolved after a test pipeline is executed.\n * @beta\n */\nexport type TestPipelineResult = {\n  /**\n   * If an error was emitted by the pipeline, it will be set here.\n   */\n  error: unknown;\n\n  /**\n   * A list of documents collected at the end of the pipeline. If the subject\n   * under test is an indexer, this will be an empty array (because your\n   * indexer should have received the documents instead).\n   */\n  documents: IndexableDocument[];\n};\n\n/**\n * Test utility for Backstage Search collators, decorators, and indexers.\n * @beta\n */\nexport class TestPipeline {\n  private collator?: Readable;\n  private decorator?: Transform;\n  private indexer?: Writable;\n\n  private constructor({\n    collator,\n    decorator,\n    indexer,\n  }: {\n    collator?: Readable;\n    decorator?: Transform;\n    indexer?: Writable;\n  }) {\n    this.collator = collator;\n    this.decorator = decorator;\n    this.indexer = indexer;\n  }\n\n  /**\n   * Provide the collator, decorator, or indexer to be tested.\n   */\n  static withSubject(subject: Readable | Transform | Writable) {\n    if (subject instanceof Transform) {\n      return new TestPipeline({ decorator: subject });\n    }\n\n    if (subject instanceof Readable) {\n      return new TestPipeline({ collator: subject });\n    }\n\n    if (subject instanceof Writable) {\n      return new TestPipeline({ indexer: subject });\n    }\n\n    throw new Error(\n      'Unknown test subject: are you passing a readable, writable, or transform stream?',\n    );\n  }\n\n  /**\n   * Provide documents for testing decorators and indexers.\n   */\n  withDocuments(documents: IndexableDocument[]): TestPipeline {\n    if (this.collator) {\n      throw new Error('Cannot provide documents when testing a collator.');\n    }\n\n    // Set a naive readable stream that just pushes all given documents.\n    this.collator = new Readable({ objectMode: true });\n    this.collator._read = () => {};\n    process.nextTick(() => {\n      documents.forEach(document => {\n        this.collator!.push(document);\n      });\n      this.collator!.push(null);\n    });\n\n    return this;\n  }\n\n  /**\n   * Execute the test pipeline so that you can make assertions about the result\n   * or behavior of the given test subject.\n   */\n  async execute(): Promise<TestPipelineResult> {\n    const documents: IndexableDocument[] = [];\n    if (!this.collator) {\n      throw new Error(\n        'Cannot execute pipeline without a collator or documents',\n      );\n    }\n\n    // If we are here and there is no indexer, we are testing a collator or a\n    // decorator. Set up a naive writable that captures documents in memory.\n    if (!this.indexer) {\n      this.indexer = new Writable({ objectMode: true });\n      this.indexer._write = (document: IndexableDocument, _, done) => {\n        documents.push(document);\n        done();\n      };\n    }\n\n    return new Promise<TestPipelineResult>(done => {\n      const pipes: (Readable | Transform | Writable)[] = [this.collator!];\n      if (this.decorator) {\n        pipes.push(this.decorator);\n      }\n      pipes.push(this.indexer!);\n\n      pipeline(pipes, error => {\n        done({\n          error,\n          documents,\n        });\n      });\n    });\n  }\n}\n"],"names":["Writable","Transform","lunr","Readable"],"mappings":"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"}