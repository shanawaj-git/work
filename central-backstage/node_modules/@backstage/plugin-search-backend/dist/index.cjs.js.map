{"version":3,"file":"index.cjs.js","sources":["../src/service/AuthorizedSearchEngine.ts","../src/service/router.ts"],"sourcesContent":["/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { compact, zipObject } from 'lodash';\nimport qs from 'qs';\nimport DataLoader from 'dataloader';\nimport {\n  AuthorizeDecision,\n  AuthorizeQuery,\n  AuthorizeResult,\n  PermissionAuthorizer,\n} from '@backstage/plugin-permission-common';\nimport {\n  DocumentTypeInfo,\n  QueryRequestOptions,\n  QueryTranslator,\n  SearchEngine,\n  SearchQuery,\n  SearchResult,\n  SearchResultSet,\n} from '@backstage/plugin-search-common';\nimport { Config } from '@backstage/config';\nimport { InputError } from '@backstage/errors';\nimport { Writable } from 'stream';\n\nexport function decodePageCursor(pageCursor?: string): { page: number } {\n  if (!pageCursor) {\n    return { page: 0 };\n  }\n\n  const page = Number(Buffer.from(pageCursor, 'base64').toString('utf-8'));\n  if (isNaN(page)) {\n    throw new InputError('Invalid page cursor');\n  }\n\n  if (page < 0) {\n    throw new InputError('Invalid page cursor');\n  }\n\n  return {\n    page,\n  };\n}\n\nexport function encodePageCursor({ page }: { page: number }): string {\n  return Buffer.from(`${page}`, 'utf-8').toString('base64');\n}\n\nexport class AuthorizedSearchEngine implements SearchEngine {\n  private readonly pageSize = 25;\n  private readonly queryLatencyBudgetMs: number;\n\n  constructor(\n    private readonly searchEngine: SearchEngine,\n    private readonly types: Record<string, DocumentTypeInfo>,\n    private readonly permissions: PermissionAuthorizer,\n    config: Config,\n  ) {\n    this.queryLatencyBudgetMs =\n      config.getOptionalNumber('search.permissions.queryLatencyBudgetMs') ??\n      1000;\n  }\n\n  setTranslator(translator: QueryTranslator): void {\n    this.searchEngine.setTranslator(translator);\n  }\n\n  async getIndexer(type: string): Promise<Writable> {\n    return this.searchEngine.getIndexer(type);\n  }\n\n  async query(\n    query: SearchQuery,\n    options: QueryRequestOptions,\n  ): Promise<SearchResultSet> {\n    const queryStartTime = Date.now();\n\n    const authorizer = new DataLoader(\n      (requests: readonly AuthorizeQuery[]) =>\n        this.permissions.authorize(requests.slice(), options),\n      {\n        // Serialize the permission name and resourceRef as\n        // a query string to avoid collisions from overlapping\n        // permission names and resourceRefs.\n        cacheKeyFn: ({ permission: { name }, resourceRef }) =>\n          qs.stringify({ name, resourceRef }),\n      },\n    );\n    const requestedTypes = query.types || Object.keys(this.types);\n\n    const typeDecisions = zipObject(\n      requestedTypes,\n      await Promise.all(\n        requestedTypes.map(type => {\n          const permission = this.types[type]?.visibilityPermission;\n\n          return permission\n            ? authorizer.load({ permission })\n            : { result: AuthorizeResult.ALLOW as const };\n        }),\n      ),\n    );\n\n    const authorizedTypes = requestedTypes.filter(\n      type => typeDecisions[type]?.result !== AuthorizeResult.DENY,\n    );\n\n    const resultByResultFilteringRequired = authorizedTypes.some(\n      type => typeDecisions[type]?.result === AuthorizeResult.CONDITIONAL,\n    );\n\n    // When there are no CONDITIONAL decisions for any of the requested\n    // result types, we can skip filtering result by result by simply\n    // skipping the types the user is not permitted to see, which will\n    // be much more efficient.\n    //\n    // Since it's not currently possible to configure the page size used\n    // by search engines, this detail means that a single user might see\n    // a different page size depending on whether their search required\n    // result-by-result filtering or not. We can fix this minor\n    // inconsistency by introducing a configurable page size.\n    //\n    // cf. https://github.com/backstage/backstage/issues/9162\n    if (!resultByResultFilteringRequired) {\n      return this.searchEngine.query(\n        { ...query, types: authorizedTypes },\n        options,\n      );\n    }\n\n    const { page } = decodePageCursor(query.pageCursor);\n    const targetResults = (page + 1) * this.pageSize;\n\n    let filteredResults: SearchResult[] = [];\n    let nextPageCursor: string | undefined;\n    let latencyBudgetExhausted = false;\n\n    do {\n      const nextPage = await this.searchEngine.query(\n        { ...query, types: authorizedTypes, pageCursor: nextPageCursor },\n        options,\n      );\n\n      filteredResults = filteredResults.concat(\n        await this.filterResults(nextPage.results, typeDecisions, authorizer),\n      );\n\n      nextPageCursor = nextPage.nextPageCursor;\n      latencyBudgetExhausted =\n        Date.now() - queryStartTime > this.queryLatencyBudgetMs;\n    } while (\n      nextPageCursor &&\n      filteredResults.length < targetResults &&\n      !latencyBudgetExhausted\n    );\n\n    return {\n      results: filteredResults.slice(\n        page * this.pageSize,\n        (page + 1) * this.pageSize,\n      ),\n      previousPageCursor:\n        page === 0 ? undefined : encodePageCursor({ page: page - 1 }),\n      nextPageCursor:\n        !latencyBudgetExhausted &&\n        (nextPageCursor || filteredResults.length > targetResults)\n          ? encodePageCursor({ page: page + 1 })\n          : undefined,\n    };\n  }\n\n  private async filterResults(\n    results: SearchResult[],\n    typeDecisions: Record<string, AuthorizeDecision>,\n    authorizer: DataLoader<AuthorizeQuery, AuthorizeDecision>,\n  ) {\n    return compact(\n      await Promise.all(\n        results.map(result => {\n          if (typeDecisions[result.type]?.result === AuthorizeResult.ALLOW) {\n            return result;\n          }\n\n          const permission = this.types[result.type]?.visibilityPermission;\n          const resourceRef = result.document.authorization?.resourceRef;\n\n          if (!permission || !resourceRef) {\n            return result;\n          }\n\n          return authorizer\n            .load({ permission, resourceRef })\n            .then(decision =>\n              decision.result === AuthorizeResult.ALLOW ? result : undefined,\n            );\n        }),\n      ),\n    );\n  }\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport express from 'express';\nimport Router from 'express-promise-router';\nimport { Logger } from 'winston';\nimport { z } from 'zod';\nimport { errorHandler } from '@backstage/backend-common';\nimport { InputError } from '@backstage/errors';\nimport { Config } from '@backstage/config';\nimport { JsonObject, JsonValue } from '@backstage/types';\nimport { getBearerTokenFromAuthorizationHeader } from '@backstage/plugin-auth-node';\nimport { PermissionAuthorizer } from '@backstage/plugin-permission-common';\nimport {\n  DocumentTypeInfo,\n  SearchResultSet,\n} from '@backstage/plugin-search-common';\nimport { SearchEngine } from '@backstage/plugin-search-backend-node';\nimport { AuthorizedSearchEngine } from './AuthorizedSearchEngine';\n\nconst jsonObjectSchema: z.ZodSchema<JsonObject> = z.lazy(() => {\n  const jsonValueSchema: z.ZodSchema<JsonValue> = z.lazy(() =>\n    z.union([\n      z.string(),\n      z.number(),\n      z.boolean(),\n      z.null(),\n      z.array(jsonValueSchema),\n      jsonObjectSchema,\n    ]),\n  );\n\n  return z.record(jsonValueSchema);\n});\n\nexport type RouterOptions = {\n  engine: SearchEngine;\n  types: Record<string, DocumentTypeInfo>;\n  permissions: PermissionAuthorizer;\n  config: Config;\n  logger: Logger;\n};\n\nconst allowedLocationProtocols = ['http:', 'https:'];\n\nexport async function createRouter(\n  options: RouterOptions,\n): Promise<express.Router> {\n  const { engine: inputEngine, types, permissions, config, logger } = options;\n\n  const requestSchema = z.object({\n    term: z.string().default(''),\n    filters: jsonObjectSchema.optional(),\n    types: z\n      .array(z.string().refine(type => Object.keys(types).includes(type)))\n      .optional(),\n    pageCursor: z.string().optional(),\n  });\n\n  const engine = config.getOptionalBoolean('permission.enabled')\n    ? new AuthorizedSearchEngine(inputEngine, types, permissions, config)\n    : inputEngine;\n\n  const filterResultSet = ({ results, ...resultSet }: SearchResultSet) => ({\n    ...resultSet,\n    results: results.filter(result => {\n      const protocol = new URL(result.document.location, 'https://example.com')\n        .protocol;\n      const isAllowed = allowedLocationProtocols.includes(protocol);\n      if (!isAllowed) {\n        logger.info(\n          `Rejected search result for \"${result.document.title}\" as location protocol \"${protocol}\" is unsafe`,\n        );\n      }\n      return isAllowed;\n    }),\n  });\n\n  const router = Router();\n  router.get(\n    '/query',\n    async (req: express.Request, res: express.Response<SearchResultSet>) => {\n      const parseResult = requestSchema.safeParse(req.query);\n\n      if (!parseResult.success) {\n        throw new InputError(`Invalid query string: ${parseResult.error}`);\n      }\n\n      const query = parseResult.data;\n\n      logger.info(\n        `Search request received: term=\"${\n          query.term\n        }\", filters=${JSON.stringify(query.filters)}, types=${\n          query.types ? query.types.join(',') : ''\n        }, pageCursor=${query.pageCursor ?? ''}`,\n      );\n\n      const token = getBearerTokenFromAuthorizationHeader(\n        req.header('authorization'),\n      );\n\n      try {\n        const resultSet = await engine?.query(query, { token });\n\n        res.send(filterResultSet(resultSet));\n      } catch (err) {\n        throw new Error(\n          `There was a problem performing the search query. ${err}`,\n        );\n      }\n    },\n  );\n\n  router.use(errorHandler());\n\n  return router;\n}\n"],"names":["InputError","DataLoader","qs","zipObject","AuthorizeResult","compact","z","Router","getBearerTokenFromAuthorizationHeader","errorHandler"],"mappings":"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"}