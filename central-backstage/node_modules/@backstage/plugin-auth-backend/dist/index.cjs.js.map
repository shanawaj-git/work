{"version":3,"file":"index.cjs.js","sources":["../src/providers/atlassian/strategy.ts","../src/lib/oauth/helpers.ts","../src/lib/oauth/OAuthEnvironmentHandler.ts","../src/lib/flow/authFlowHelpers.ts","../src/providers/prepareBackstageIdentityResponse.ts","../src/lib/oauth/OAuthAdapter.ts","../src/lib/passport/PassportStrategyHelper.ts","../src/lib/catalog/CatalogIdentityClient.ts","../src/lib/catalog/helpers.ts","../src/providers/atlassian/provider.ts","../src/providers/auth0/strategy.ts","../src/providers/auth0/provider.ts","../src/providers/aws-alb/provider.ts","../src/providers/bitbucket/provider.ts","../src/providers/github/provider.ts","../src/providers/gitlab/provider.ts","../src/providers/google/provider.ts","../src/providers/microsoft/provider.ts","../src/providers/oauth2/provider.ts","../src/providers/oauth2-proxy/provider.ts","../src/providers/oidc/provider.ts","../src/providers/okta/provider.ts","../src/providers/onelogin/provider.ts","../src/providers/saml/provider.ts","../src/providers/gcp-iap/types.ts","../src/providers/gcp-iap/helpers.ts","../src/providers/gcp-iap/provider.ts","../src/providers/factories.ts","../src/identity/router.ts","../src/identity/TokenFactory.ts","../src/identity/DatabaseKeyStore.ts","../src/identity/MemoryKeyStore.ts","../src/identity/FirestoreKeyStore.ts","../src/identity/KeyStores.ts","../src/service/router.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport OAuth2Strategy, { InternalOAuthError } from 'passport-oauth2';\nimport { Profile } from 'passport';\n\ninterface ProfileResponse {\n  account_id: string;\n  email: string;\n  name: string;\n  picture: string;\n  nickname: string;\n}\n\ninterface AtlassianStrategyOptions {\n  clientID: string;\n  clientSecret: string;\n  callbackURL: string;\n  scope: string;\n}\n\nconst defaultScopes = ['offline_access', 'read:me'];\n\nexport default class AtlassianStrategy extends OAuth2Strategy {\n  private readonly profileURL: string;\n\n  constructor(\n    options: AtlassianStrategyOptions,\n    verify: OAuth2Strategy.VerifyFunction,\n  ) {\n    if (!options.scope) {\n      throw new TypeError('Atlassian requires a scope option');\n    }\n\n    const scopes = options.scope.split(' ');\n\n    const optionsWithURLs = {\n      ...options,\n      authorizationURL: `https://auth.atlassian.com/authorize`,\n      tokenURL: `https://auth.atlassian.com/oauth/token`,\n      scope: Array.from(new Set([...defaultScopes, ...scopes])),\n    };\n\n    super(optionsWithURLs, verify);\n    this.profileURL = 'https://api.atlassian.com/me';\n    this.name = 'atlassian';\n\n    this._oauth2.useAuthorizationHeaderforGET(true);\n  }\n\n  authorizationParams() {\n    return {\n      audience: 'api.atlassian.com',\n      prompt: 'consent',\n    };\n  }\n\n  userProfile(\n    accessToken: string,\n    done: (err?: Error | null, profile?: any) => void,\n  ): void {\n    this._oauth2.get(this.profileURL, accessToken, (err, body) => {\n      if (err) {\n        return done(\n          new InternalOAuthError(\n            'Failed to fetch user profile',\n            err.statusCode,\n          ),\n        );\n      }\n\n      if (!body) {\n        return done(\n          new Error('Failed to fetch user profile, body cannot be empty'),\n        );\n      }\n\n      try {\n        const json = typeof body !== 'string' ? body.toString() : body;\n        const profile = AtlassianStrategy.parse(json);\n        return done(null, profile);\n      } catch (e) {\n        return done(new Error('Failed to parse user profile'));\n      }\n    });\n  }\n\n  static parse(json: string): Profile {\n    const resp = JSON.parse(json) as ProfileResponse;\n\n    return {\n      id: resp.account_id,\n      provider: 'atlassian',\n      username: resp.nickname,\n      displayName: resp.name,\n      emails: [{ value: resp.email }],\n      photos: [{ value: resp.picture }],\n    };\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport express from 'express';\nimport { OAuthState } from './types';\nimport pickBy from 'lodash/pickBy';\nimport { CookieConfigurer } from '../../providers/types';\n\nexport const readState = (stateString: string): OAuthState => {\n  const state = Object.fromEntries(\n    new URLSearchParams(Buffer.from(stateString, 'hex').toString('utf-8')),\n  );\n  if (\n    !state.nonce ||\n    !state.env ||\n    state.nonce?.length === 0 ||\n    state.env?.length === 0\n  ) {\n    throw Error(`Invalid state passed via request`);\n  }\n\n  return state as OAuthState;\n};\n\nexport const encodeState = (state: OAuthState): string => {\n  const stateString = new URLSearchParams(\n    pickBy<string>(state, value => value !== undefined),\n  ).toString();\n\n  return Buffer.from(stateString, 'utf-8').toString('hex');\n};\n\nexport const verifyNonce = (req: express.Request, providerId: string) => {\n  const cookieNonce = req.cookies[`${providerId}-nonce`];\n  const state: OAuthState = readState(req.query.state?.toString() ?? '');\n  const stateNonce = state.nonce;\n\n  if (!cookieNonce) {\n    throw new Error('Auth response is missing cookie nonce');\n  }\n  if (stateNonce.length === 0) {\n    throw new Error('Auth response is missing state nonce');\n  }\n  if (cookieNonce !== stateNonce) {\n    throw new Error('Invalid nonce');\n  }\n};\n\nexport const defaultCookieConfigurer: CookieConfigurer = ({\n  callbackUrl,\n  providerId,\n}) => {\n  const { hostname: domain, pathname, protocol } = new URL(callbackUrl);\n  const secure = protocol === 'https:';\n\n  // If the provider supports callbackUrls, the pathname will\n  // contain the complete path to the frame handler so we need\n  // to slice off the trailing part of the path.\n  const path = pathname.endsWith(`${providerId}/handler/frame`)\n    ? pathname.slice(0, -'/handler/frame'.length)\n    : `${pathname}/${providerId}`;\n\n  return { domain, path, secure };\n};\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport express from 'express';\nimport { Config } from '@backstage/config';\nimport { InputError, NotFoundError } from '@backstage/errors';\nimport { readState } from './helpers';\nimport { AuthProviderRouteHandlers } from '../../providers/types';\n\nexport class OAuthEnvironmentHandler implements AuthProviderRouteHandlers {\n  static mapConfig(\n    config: Config,\n    factoryFunc: (envConfig: Config) => AuthProviderRouteHandlers,\n  ) {\n    const envs = config.keys();\n    const handlers = new Map<string, AuthProviderRouteHandlers>();\n\n    for (const env of envs) {\n      const envConfig = config.getConfig(env);\n      const handler = factoryFunc(envConfig);\n      handlers.set(env, handler);\n    }\n\n    return new OAuthEnvironmentHandler(handlers);\n  }\n\n  constructor(\n    private readonly handlers: Map<string, AuthProviderRouteHandlers>,\n  ) {}\n\n  async start(req: express.Request, res: express.Response): Promise<void> {\n    const provider = this.getProviderForEnv(req);\n    await provider.start(req, res);\n  }\n\n  async frameHandler(\n    req: express.Request,\n    res: express.Response,\n  ): Promise<void> {\n    const provider = this.getProviderForEnv(req);\n    await provider.frameHandler(req, res);\n  }\n\n  async refresh(req: express.Request, res: express.Response): Promise<void> {\n    const provider = this.getProviderForEnv(req);\n    await provider.refresh?.(req, res);\n  }\n\n  async logout(req: express.Request, res: express.Response): Promise<void> {\n    const provider = this.getProviderForEnv(req);\n    await provider.logout?.(req, res);\n  }\n\n  private getRequestFromEnv(req: express.Request): string | undefined {\n    const reqEnv = req.query.env?.toString();\n    if (reqEnv) {\n      return reqEnv;\n    }\n    const stateParams = req.query.state?.toString();\n    if (!stateParams) {\n      return undefined;\n    }\n    const env = readState(stateParams).env;\n    return env;\n  }\n\n  private getProviderForEnv(req: express.Request): AuthProviderRouteHandlers {\n    const env: string | undefined = this.getRequestFromEnv(req);\n\n    if (!env) {\n      throw new InputError(`Must specify 'env' query to select environment`);\n    }\n\n    const handler = this.handlers.get(env);\n    if (!handler) {\n      throw new NotFoundError(\n        `No configuration available for the '${env}' environment of this provider.`,\n      );\n    }\n\n    return handler;\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport express from 'express';\nimport crypto from 'crypto';\nimport { WebMessageResponse } from './types';\n\nexport const safelyEncodeURIComponent = (value: string) => {\n  // Note the g at the end of the regex; all occurrences of single quotes must\n  // be replaced, which encodeURIComponent does not do itself by default\n  return encodeURIComponent(value).replace(/'/g, '%27');\n};\n\nexport const postMessageResponse = (\n  res: express.Response,\n  appOrigin: string,\n  response: WebMessageResponse,\n) => {\n  const jsonData = JSON.stringify(response);\n  const base64Data = safelyEncodeURIComponent(jsonData);\n  const base64Origin = safelyEncodeURIComponent(appOrigin);\n\n  // NOTE: It is absolutely imperative that we use the safe encoder above, to\n  // be sure that the js code below does not allow the injection of malicious\n  // data.\n\n  // TODO: Make target app origin configurable globally\n\n  //\n  // postMessage fails silently if the targetOrigin is disallowed.\n  // So 2 postMessages are sent from the popup to the parent window.\n  // First, the origin being used to post the actual authorization response is\n  // shared with the parent window with a postMessage with targetOrigin '*'.\n  // Second, the actual authorization response is sent with the app origin\n  // as the targetOrigin.\n  // If the first message was received but the actual auth response was\n  // never received, the event listener can conclude that targetOrigin\n  // was disallowed, indicating potential misconfiguration.\n  //\n  const script = `\n    var authResponse = decodeURIComponent('${base64Data}');\n    var origin = decodeURIComponent('${base64Origin}');\n    var originInfo = {'type': 'config_info', 'targetOrigin': origin};\n    (window.opener || window.parent).postMessage(originInfo, '*');\n    (window.opener || window.parent).postMessage(JSON.parse(authResponse), origin);\n    setTimeout(() => {\n      window.close();\n    }, 100); // same as the interval of the core-app-api lib/loginPopup.ts (to address race conditions)\n  `;\n  const hash = crypto.createHash('sha256').update(script).digest('base64');\n\n  res.setHeader('Content-Type', 'text/html');\n  res.setHeader('X-Frame-Options', 'sameorigin');\n  res.setHeader('Content-Security-Policy', `script-src 'sha256-${hash}'`);\n  res.end(`<html><body><script>${script}</script></body></html>`);\n};\n\nexport const ensuresXRequestedWith = (req: express.Request) => {\n  const requiredHeader = req.header('X-Requested-With');\n  if (!requiredHeader || requiredHeader !== 'XMLHttpRequest') {\n    return false;\n  }\n  return true;\n};\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DEFAULT_NAMESPACE,\n  parseEntityRef,\n  stringifyEntityRef,\n} from '@backstage/catalog-model';\nimport {\n  BackstageIdentityResponse,\n  BackstageSignInResult,\n} from '@backstage/plugin-auth-node';\n\nfunction parseJwtPayload(token: string) {\n  const [_header, payload, _signature] = token.split('.');\n  return JSON.parse(Buffer.from(payload, 'base64').toString());\n}\n\n/**\n * Parses a Backstage-issued token and decorates the\n * {@link @backstage/plugin-auth-node#BackstageIdentityResponse} with identity information sourced from the\n * token.\n *\n * @public\n */\nexport function prepareBackstageIdentityResponse(\n  result: BackstageSignInResult,\n): BackstageIdentityResponse {\n  const { sub, ent } = parseJwtPayload(result.token);\n\n  const userEntityRef = stringifyEntityRef(\n    parseEntityRef(sub, {\n      defaultKind: 'user',\n      defaultNamespace: DEFAULT_NAMESPACE,\n    }),\n  );\n  return {\n    ...{\n      // TODO: idToken is for backwards compatibility and can be removed in the future\n      idToken: result.token,\n      ...result,\n    },\n    identity: {\n      type: 'user',\n      userEntityRef,\n      ownershipEntityRefs: ent ?? [],\n    },\n  };\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport express, { CookieOptions } from 'express';\nimport crypto from 'crypto';\nimport { URL } from 'url';\nimport {\n  DEFAULT_NAMESPACE,\n  parseEntityRef,\n  stringifyEntityRef,\n} from '@backstage/catalog-model';\nimport {\n  BackstageIdentityResponse,\n  BackstageSignInResult,\n} from '@backstage/plugin-auth-node';\nimport {\n  AuthProviderRouteHandlers,\n  AuthProviderConfig,\n} from '../../providers/types';\nimport {\n  AuthenticationError,\n  InputError,\n  isError,\n  NotAllowedError,\n} from '@backstage/errors';\nimport { TokenIssuer } from '../../identity/types';\nimport { defaultCookieConfigurer, readState, verifyNonce } from './helpers';\nimport { postMessageResponse, ensuresXRequestedWith } from '../flow';\nimport {\n  OAuthHandlers,\n  OAuthStartRequest,\n  OAuthRefreshRequest,\n  OAuthState,\n} from './types';\nimport { prepareBackstageIdentityResponse } from '../../providers/prepareBackstageIdentityResponse';\n\nexport const THOUSAND_DAYS_MS = 1000 * 24 * 60 * 60 * 1000;\nexport const TEN_MINUTES_MS = 600 * 1000;\n\nexport type Options = {\n  providerId: string;\n  secure: boolean;\n  disableRefresh?: boolean;\n  persistScopes?: boolean;\n  cookieDomain: string;\n  cookiePath: string;\n  appOrigin: string;\n  tokenIssuer: TokenIssuer;\n  isOriginAllowed: (origin: string) => boolean;\n  callbackUrl: string;\n};\nexport class OAuthAdapter implements AuthProviderRouteHandlers {\n  static fromConfig(\n    config: AuthProviderConfig,\n    handlers: OAuthHandlers,\n    options: Pick<\n      Options,\n      | 'providerId'\n      | 'persistScopes'\n      | 'disableRefresh'\n      | 'tokenIssuer'\n      | 'callbackUrl'\n    >,\n  ): OAuthAdapter {\n    const { origin: appOrigin } = new URL(config.appUrl);\n\n    const cookieConfigurer = config.cookieConfigurer ?? defaultCookieConfigurer;\n    const cookieConfig = cookieConfigurer({\n      providerId: options.providerId,\n      baseUrl: config.baseUrl,\n      callbackUrl: options.callbackUrl,\n    });\n\n    return new OAuthAdapter(handlers, {\n      ...options,\n      appOrigin,\n      cookieDomain: cookieConfig.domain,\n      cookiePath: cookieConfig.path,\n      secure: cookieConfig.secure,\n      isOriginAllowed: config.isOriginAllowed,\n    });\n  }\n\n  private readonly baseCookieOptions: CookieOptions;\n\n  constructor(\n    private readonly handlers: OAuthHandlers,\n    private readonly options: Options,\n  ) {\n    this.baseCookieOptions = {\n      httpOnly: true,\n      sameSite: 'lax',\n      secure: this.options.secure,\n      path: this.options.cookiePath,\n      domain: this.options.cookieDomain,\n    };\n  }\n\n  async start(req: express.Request, res: express.Response): Promise<void> {\n    // retrieve scopes from request\n    const scope = req.query.scope?.toString() ?? '';\n    const env = req.query.env?.toString();\n    const origin = req.query.origin?.toString();\n\n    if (!env) {\n      throw new InputError('No env provided in request query parameters');\n    }\n\n    const nonce = crypto.randomBytes(16).toString('base64');\n    // set a nonce cookie before redirecting to oauth provider\n    this.setNonceCookie(res, nonce);\n\n    const state: OAuthState = { nonce, env, origin };\n\n    // If scopes are persisted then we pass them through the state so that we\n    // can set the cookie on successful auth\n    if (this.options.persistScopes) {\n      state.scope = scope;\n    }\n    const forwardReq = Object.assign(req, { scope, state });\n\n    const { url, status } = await this.handlers.start(\n      forwardReq as OAuthStartRequest,\n    );\n\n    res.statusCode = status || 302;\n    res.setHeader('Location', url);\n    res.setHeader('Content-Length', '0');\n    res.end();\n  }\n\n  async frameHandler(\n    req: express.Request,\n    res: express.Response,\n  ): Promise<void> {\n    let appOrigin = this.options.appOrigin;\n\n    try {\n      const state: OAuthState = readState(req.query.state?.toString() ?? '');\n\n      if (state.origin) {\n        try {\n          appOrigin = new URL(state.origin).origin;\n        } catch {\n          throw new NotAllowedError('App origin is invalid, failed to parse');\n        }\n        if (!this.options.isOriginAllowed(appOrigin)) {\n          throw new NotAllowedError(`Origin '${appOrigin}' is not allowed`);\n        }\n      }\n\n      // verify nonce cookie and state cookie on callback\n      verifyNonce(req, this.options.providerId);\n\n      const { response, refreshToken } = await this.handlers.handler(req);\n\n      // Store the scope that we have been granted for this session. This is useful if\n      // the provider does not return granted scopes on refresh or if they are normalized.\n      if (this.options.persistScopes && state.scope) {\n        this.setGrantedScopeCookie(res, state.scope);\n        response.providerInfo.scope = state.scope;\n      }\n\n      if (refreshToken && !this.options.disableRefresh) {\n        // set new refresh token\n        this.setRefreshTokenCookie(res, refreshToken);\n      }\n\n      const identity = await this.populateIdentity(response.backstageIdentity);\n\n      // post message back to popup if successful\n      return postMessageResponse(res, appOrigin, {\n        type: 'authorization_response',\n        response: { ...response, backstageIdentity: identity },\n      });\n    } catch (error) {\n      const { name, message } = isError(error)\n        ? error\n        : new Error('Encountered invalid error'); // Being a bit safe and not forwarding the bad value\n      // post error message back to popup if failure\n      return postMessageResponse(res, appOrigin, {\n        type: 'authorization_response',\n        error: { name, message },\n      });\n    }\n  }\n\n  async logout(req: express.Request, res: express.Response): Promise<void> {\n    if (!ensuresXRequestedWith(req)) {\n      throw new AuthenticationError('Invalid X-Requested-With header');\n    }\n\n    // remove refresh token cookie if it is set\n    this.removeRefreshTokenCookie(res);\n\n    res.status(200).end();\n  }\n\n  async refresh(req: express.Request, res: express.Response): Promise<void> {\n    if (!ensuresXRequestedWith(req)) {\n      throw new AuthenticationError('Invalid X-Requested-With header');\n    }\n\n    if (!this.handlers.refresh || this.options.disableRefresh) {\n      throw new InputError(\n        `Refresh token is not supported for provider ${this.options.providerId}`,\n      );\n    }\n\n    try {\n      const refreshToken =\n        req.cookies[`${this.options.providerId}-refresh-token`];\n\n      // throw error if refresh token is missing in the request\n      if (!refreshToken) {\n        throw new InputError('Missing session cookie');\n      }\n\n      let scope = req.query.scope?.toString() ?? '';\n      if (this.options.persistScopes) {\n        scope = this.getGrantedScopeFromCookie(req);\n      }\n      const forwardReq = Object.assign(req, { scope, refreshToken });\n\n      // get new access_token\n      const { response, refreshToken: newRefreshToken } =\n        await this.handlers.refresh(forwardReq as OAuthRefreshRequest);\n\n      const backstageIdentity = await this.populateIdentity(\n        response.backstageIdentity,\n      );\n\n      if (newRefreshToken && newRefreshToken !== refreshToken) {\n        this.setRefreshTokenCookie(res, newRefreshToken);\n      }\n\n      res.status(200).json({ ...response, backstageIdentity });\n    } catch (error) {\n      throw new AuthenticationError('Refresh failed', error);\n    }\n  }\n\n  /**\n   * If the response from the OAuth provider includes a Backstage identity, we\n   * make sure it's populated with all the information we can derive from the user ID.\n   */\n  private async populateIdentity(\n    identity?: BackstageSignInResult,\n  ): Promise<BackstageIdentityResponse | undefined> {\n    if (!identity) {\n      return undefined;\n    }\n\n    if (identity.token) {\n      return prepareBackstageIdentityResponse(identity);\n    }\n\n    const userEntityRef = stringifyEntityRef(\n      parseEntityRef(identity.id, {\n        defaultKind: 'user',\n        defaultNamespace: DEFAULT_NAMESPACE,\n      }),\n    );\n    const token = await this.options.tokenIssuer.issueToken({\n      claims: { sub: userEntityRef },\n    });\n\n    return prepareBackstageIdentityResponse({ ...identity, token });\n  }\n\n  private setNonceCookie = (res: express.Response, nonce: string) => {\n    res.cookie(`${this.options.providerId}-nonce`, nonce, {\n      maxAge: TEN_MINUTES_MS,\n      ...this.baseCookieOptions,\n      path: `${this.options.cookiePath}/handler`,\n    });\n  };\n\n  private setGrantedScopeCookie = (res: express.Response, scope: string) => {\n    res.cookie(`${this.options.providerId}-granted-scope`, scope, {\n      maxAge: THOUSAND_DAYS_MS,\n      ...this.baseCookieOptions,\n    });\n  };\n\n  private getGrantedScopeFromCookie = (req: express.Request) => {\n    return req.cookies[`${this.options.providerId}-granted-scope`];\n  };\n\n  private setRefreshTokenCookie = (\n    res: express.Response,\n    refreshToken: string,\n  ) => {\n    res.cookie(`${this.options.providerId}-refresh-token`, refreshToken, {\n      maxAge: THOUSAND_DAYS_MS,\n      ...this.baseCookieOptions,\n    });\n  };\n\n  private removeRefreshTokenCookie = (res: express.Response) => {\n    res.cookie(`${this.options.providerId}-refresh-token`, '', {\n      maxAge: 0,\n      ...this.baseCookieOptions,\n    });\n  };\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport express from 'express';\nimport passport from 'passport';\nimport jwtDecoder from 'jwt-decode';\nimport { InternalOAuthError } from 'passport-oauth2';\n\nimport { PassportProfile } from './types';\nimport { ProfileInfo, RedirectInfo } from '../../providers/types';\n\nexport type PassportDoneCallback<Res, Private = never> = (\n  err?: Error,\n  response?: Res,\n  privateInfo?: Private,\n) => void;\n\nexport const makeProfileInfo = (\n  profile: PassportProfile,\n  idToken?: string,\n): ProfileInfo => {\n  let email: string | undefined = undefined;\n  if (profile.emails && profile.emails.length > 0) {\n    const [firstEmail] = profile.emails;\n    email = firstEmail.value;\n  }\n\n  let picture: string | undefined = undefined;\n  if (profile.avatarUrl) {\n    picture = profile.avatarUrl;\n  } else if (profile.photos && profile.photos.length > 0) {\n    const [firstPhoto] = profile.photos;\n    picture = firstPhoto.value;\n  }\n\n  let displayName: string | undefined =\n    profile.displayName ?? profile.username ?? profile.id;\n\n  if ((!email || !picture || !displayName) && idToken) {\n    try {\n      const decoded: Record<string, string> = jwtDecoder(idToken);\n      if (!email && decoded.email) {\n        email = decoded.email;\n      }\n      if (!picture && decoded.picture) {\n        picture = decoded.picture;\n      }\n      if (!displayName && decoded.name) {\n        displayName = decoded.name;\n      }\n    } catch (e) {\n      throw new Error(`Failed to parse id token and get profile info, ${e}`);\n    }\n  }\n\n  return {\n    email,\n    picture,\n    displayName,\n  };\n};\n\nexport const executeRedirectStrategy = async (\n  req: express.Request,\n  providerStrategy: passport.Strategy,\n  options: Record<string, string>,\n): Promise<RedirectInfo> => {\n  return new Promise(resolve => {\n    const strategy = Object.create(providerStrategy);\n    strategy.redirect = (url: string, status?: number) => {\n      resolve({ url, status: status ?? undefined });\n    };\n\n    strategy.authenticate(req, { ...options });\n  });\n};\n\nexport const executeFrameHandlerStrategy = async <Result, PrivateInfo = never>(\n  req: express.Request,\n  providerStrategy: passport.Strategy,\n) => {\n  return new Promise<{ result: Result; privateInfo: PrivateInfo }>(\n    (resolve, reject) => {\n      const strategy = Object.create(providerStrategy);\n      strategy.success = (result: any, privateInfo: any) => {\n        resolve({ result, privateInfo });\n      };\n      strategy.fail = (\n        info: { type: 'success' | 'error'; message?: string },\n        // _status: number,\n      ) => {\n        reject(new Error(`Authentication rejected, ${info.message ?? ''}`));\n      };\n      strategy.error = (error: InternalOAuthError) => {\n        let message = `Authentication failed, ${error.message}`;\n\n        if (error.oauthError?.data) {\n          try {\n            const errorData = JSON.parse(error.oauthError.data);\n\n            if (errorData.message) {\n              message += ` - ${errorData.message}`;\n            }\n          } catch (parseError) {\n            message += ` - ${error.oauthError}`;\n          }\n        }\n\n        reject(new Error(message));\n      };\n      strategy.redirect = () => {\n        reject(new Error('Unexpected redirect'));\n      };\n      strategy.authenticate(req, {});\n    },\n  );\n};\n\ntype RefreshTokenResponse = {\n  /**\n   * An access token issued for the signed in user.\n   */\n  accessToken: string;\n  /**\n   * Optionally, the server can issue a new Refresh Token for the user\n   */\n  refreshToken?: string;\n  params: any;\n};\n\nexport const executeRefreshTokenStrategy = async (\n  providerStrategy: passport.Strategy,\n  refreshToken: string,\n  scope: string,\n): Promise<RefreshTokenResponse> => {\n  return new Promise((resolve, reject) => {\n    const anyStrategy = providerStrategy as any;\n    const OAuth2 = anyStrategy._oauth2.constructor;\n    const oauth2 = new OAuth2(\n      anyStrategy._oauth2._clientId,\n      anyStrategy._oauth2._clientSecret,\n      anyStrategy._oauth2._baseSite,\n      anyStrategy._oauth2._authorizeUrl,\n      anyStrategy._refreshURL || anyStrategy._oauth2._accessTokenUrl,\n      anyStrategy._oauth2._customHeaders,\n    );\n\n    oauth2.getOAuthAccessToken(\n      refreshToken,\n      {\n        scope,\n        grant_type: 'refresh_token',\n      },\n      (\n        err: Error | null,\n        accessToken: string,\n        newRefreshToken: string,\n        params: any,\n      ) => {\n        if (err) {\n          reject(new Error(`Failed to refresh access token ${err.toString()}`));\n        }\n        if (!accessToken) {\n          reject(\n            new Error(\n              `Failed to refresh access token, no access token received`,\n            ),\n          );\n        }\n\n        resolve({\n          accessToken,\n          refreshToken: newRefreshToken,\n          params,\n        });\n      },\n    );\n  });\n};\n\ntype ProviderStrategy = {\n  userProfile(accessToken: string, callback: Function): void;\n};\n\nexport const executeFetchUserProfileStrategy = async (\n  providerStrategy: passport.Strategy,\n  accessToken: string,\n): Promise<PassportProfile> => {\n  return new Promise((resolve, reject) => {\n    const anyStrategy = providerStrategy as unknown as ProviderStrategy;\n    anyStrategy.userProfile(\n      accessToken,\n      (error: Error, rawProfile: PassportProfile) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(rawProfile);\n        }\n      },\n    );\n  });\n};\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Logger } from 'winston';\nimport { ConflictError, NotFoundError } from '@backstage/errors';\nimport { CatalogApi } from '@backstage/catalog-client';\nimport {\n  CompoundEntityRef,\n  parseEntityRef,\n  RELATION_MEMBER_OF,\n  stringifyEntityRef,\n  UserEntity,\n} from '@backstage/catalog-model';\nimport { TokenManager } from '@backstage/backend-common';\n\ntype UserQuery = {\n  annotations: Record<string, string>;\n};\n\ntype MemberClaimQuery = {\n  entityRefs: string[];\n  logger?: Logger;\n};\n\n/**\n * A catalog client tailored for reading out identity data from the catalog.\n */\nexport class CatalogIdentityClient {\n  private readonly catalogApi: CatalogApi;\n  private readonly tokenManager: TokenManager;\n\n  constructor(options: { catalogApi: CatalogApi; tokenManager: TokenManager }) {\n    this.catalogApi = options.catalogApi;\n    this.tokenManager = options.tokenManager;\n  }\n\n  /**\n   * Looks up a single user using a query.\n   *\n   * Throws a NotFoundError or ConflictError if 0 or multiple users are found.\n   */\n  async findUser(query: UserQuery): Promise<UserEntity> {\n    const filter: Record<string, string> = {\n      kind: 'user',\n    };\n    for (const [key, value] of Object.entries(query.annotations)) {\n      filter[`metadata.annotations.${key}`] = value;\n    }\n\n    const { token } = await this.tokenManager.getToken();\n    const { items } = await this.catalogApi.getEntities({ filter }, { token });\n\n    if (items.length !== 1) {\n      if (items.length > 1) {\n        throw new ConflictError('User lookup resulted in multiple matches');\n      } else {\n        throw new NotFoundError('User not found');\n      }\n    }\n\n    return items[0] as UserEntity;\n  }\n\n  /**\n   * Resolve additional entity claims from the catalog, using the passed-in entity names. Designed\n   * to be used within a `signInResolver` where additional entity claims might be provided, but\n   * group membership and transient group membership lean on imported catalog relations.\n   *\n   * Returns a superset of the entity names that can be passed directly to `issueToken` as `ent`.\n   */\n  async resolveCatalogMembership(query: MemberClaimQuery): Promise<string[]> {\n    const { entityRefs, logger } = query;\n    const resolvedEntityRefs = entityRefs\n      .map((ref: string) => {\n        try {\n          const parsedRef = parseEntityRef(ref.toLocaleLowerCase('en-US'), {\n            defaultKind: 'user',\n            defaultNamespace: 'default',\n          });\n          return parsedRef;\n        } catch {\n          logger?.warn(`Failed to parse entityRef from ${ref}, ignoring`);\n          return null;\n        }\n      })\n      .filter((ref): ref is CompoundEntityRef => ref !== null);\n\n    const filter = resolvedEntityRefs.map(ref => ({\n      kind: ref.kind,\n      'metadata.namespace': ref.namespace,\n      'metadata.name': ref.name,\n    }));\n    const { token } = await this.tokenManager.getToken();\n    const entities = await this.catalogApi\n      .getEntities({ filter }, { token })\n      .then(r => r.items);\n\n    if (entityRefs.length !== entities.length) {\n      const foundEntityNames = entities.map(stringifyEntityRef);\n      const missingEntityNames = resolvedEntityRefs\n        .map(stringifyEntityRef)\n        .filter(s => !foundEntityNames.includes(s));\n      logger?.debug(`Entities not found for refs ${missingEntityNames.join()}`);\n    }\n\n    const memberOf = entities.flatMap(\n      e =>\n        e!.relations\n          ?.filter(r => r.type === RELATION_MEMBER_OF)\n          .map(r => r.targetRef) ?? [],\n    );\n\n    const newEntityRefs = [\n      ...new Set(resolvedEntityRefs.map(stringifyEntityRef).concat(memberOf)),\n    ];\n\n    logger?.debug(`Found catalog membership: ${newEntityRefs.join()}`);\n    return newEntityRefs;\n  }\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  RELATION_MEMBER_OF,\n  stringifyEntityRef,\n  UserEntity,\n} from '@backstage/catalog-model';\nimport { TokenParams } from '../../identity';\n\nexport function getEntityClaims(entity: UserEntity): TokenParams['claims'] {\n  const userRef = stringifyEntityRef(entity);\n\n  const membershipRefs =\n    entity.relations\n      ?.filter(\n        r => r.type === RELATION_MEMBER_OF && r.targetRef.startsWith('group:'),\n      )\n      .map(r => r.targetRef) ?? [];\n\n  return {\n    sub: userRef,\n    ent: [userRef, ...membershipRefs],\n  };\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport AtlassianStrategy from './strategy';\nimport {\n  encodeState,\n  OAuthAdapter,\n  OAuthEnvironmentHandler,\n  OAuthHandlers,\n  OAuthProviderOptions,\n  OAuthRefreshRequest,\n  OAuthResponse,\n  OAuthResult,\n  OAuthStartRequest,\n} from '../../lib/oauth';\nimport passport from 'passport';\nimport {\n  executeFetchUserProfileStrategy,\n  executeFrameHandlerStrategy,\n  executeRedirectStrategy,\n  executeRefreshTokenStrategy,\n  makeProfileInfo,\n  PassportDoneCallback,\n} from '../../lib/passport';\nimport {\n  AuthHandler,\n  AuthProviderFactory,\n  RedirectInfo,\n  SignInResolver,\n} from '../types';\nimport express from 'express';\nimport { TokenIssuer } from '../../identity';\nimport { CatalogIdentityClient } from '../../lib/catalog';\nimport { Logger } from 'winston';\n\nexport type AtlassianAuthProviderOptions = OAuthProviderOptions & {\n  scopes: string;\n  signInResolver?: SignInResolver<OAuthResult>;\n  authHandler: AuthHandler<OAuthResult>;\n  tokenIssuer: TokenIssuer;\n  catalogIdentityClient: CatalogIdentityClient;\n  logger: Logger;\n};\n\nexport const atlassianDefaultAuthHandler: AuthHandler<OAuthResult> = async ({\n  fullProfile,\n  params,\n}) => ({\n  profile: makeProfileInfo(fullProfile, params.id_token),\n});\n\nexport class AtlassianAuthProvider implements OAuthHandlers {\n  private readonly _strategy: AtlassianStrategy;\n  private readonly signInResolver?: SignInResolver<OAuthResult>;\n  private readonly authHandler: AuthHandler<OAuthResult>;\n  private readonly tokenIssuer: TokenIssuer;\n  private readonly catalogIdentityClient: CatalogIdentityClient;\n  private readonly logger: Logger;\n\n  constructor(options: AtlassianAuthProviderOptions) {\n    this.catalogIdentityClient = options.catalogIdentityClient;\n    this.logger = options.logger;\n    this.tokenIssuer = options.tokenIssuer;\n    this.authHandler = options.authHandler;\n    this.signInResolver = options.signInResolver;\n\n    this._strategy = new AtlassianStrategy(\n      {\n        clientID: options.clientId,\n        clientSecret: options.clientSecret,\n        callbackURL: options.callbackUrl,\n        scope: options.scopes,\n      },\n      (\n        accessToken: any,\n        refreshToken: any,\n        params: any,\n        fullProfile: passport.Profile,\n        done: PassportDoneCallback<OAuthResult>,\n      ) => {\n        done(undefined, {\n          fullProfile,\n          accessToken,\n          refreshToken,\n          params,\n        });\n      },\n    );\n  }\n\n  async start(req: OAuthStartRequest): Promise<RedirectInfo> {\n    return await executeRedirectStrategy(req, this._strategy, {\n      state: encodeState(req.state),\n    });\n  }\n\n  async handler(req: express.Request) {\n    const { result } = await executeFrameHandlerStrategy<OAuthResult>(\n      req,\n      this._strategy,\n    );\n\n    return {\n      response: await this.handleResult(result),\n      refreshToken: result.refreshToken,\n    };\n  }\n\n  private async handleResult(result: OAuthResult): Promise<OAuthResponse> {\n    const context = {\n      logger: this.logger,\n      catalogIdentityClient: this.catalogIdentityClient,\n      tokenIssuer: this.tokenIssuer,\n    };\n    const { profile } = await this.authHandler(result, context);\n\n    const response: OAuthResponse = {\n      providerInfo: {\n        idToken: result.params.id_token,\n        accessToken: result.accessToken,\n        scope: result.params.scope,\n        expiresInSeconds: result.params.expires_in,\n      },\n      profile,\n    };\n\n    if (this.signInResolver) {\n      response.backstageIdentity = await this.signInResolver(\n        {\n          result,\n          profile,\n        },\n        context,\n      );\n    }\n\n    return response;\n  }\n\n  async refresh(req: OAuthRefreshRequest) {\n    const { accessToken, params, refreshToken } =\n      await executeRefreshTokenStrategy(\n        this._strategy,\n        req.refreshToken,\n        req.scope,\n      );\n\n    const fullProfile = await executeFetchUserProfileStrategy(\n      this._strategy,\n      accessToken,\n    );\n\n    return {\n      response: await this.handleResult({\n        fullProfile,\n        params,\n        accessToken,\n      }),\n      refreshToken,\n    };\n  }\n}\n\nexport type AtlassianProviderOptions = {\n  /**\n   * The profile transformation function used to verify and convert the auth response\n   * into the profile that will be presented to the user.\n   */\n  authHandler?: AuthHandler<OAuthResult>;\n\n  /**\n   * Configure sign-in for this provider, without it the provider can not be used to sign users in.\n   */\n  signIn?: {\n    resolver: SignInResolver<OAuthResult>;\n  };\n};\n\nexport const createAtlassianProvider = (\n  options?: AtlassianProviderOptions,\n): AuthProviderFactory => {\n  return ({\n    providerId,\n    globalConfig,\n    config,\n    tokenIssuer,\n    tokenManager,\n    catalogApi,\n    logger,\n  }) =>\n    OAuthEnvironmentHandler.mapConfig(config, envConfig => {\n      const clientId = envConfig.getString('clientId');\n      const clientSecret = envConfig.getString('clientSecret');\n      const scopes = envConfig.getString('scopes');\n      const customCallbackUrl = envConfig.getOptionalString('callbackUrl');\n      const callbackUrl =\n        customCallbackUrl ||\n        `${globalConfig.baseUrl}/${providerId}/handler/frame`;\n\n      const catalogIdentityClient = new CatalogIdentityClient({\n        catalogApi,\n        tokenManager,\n      });\n\n      const authHandler: AuthHandler<OAuthResult> =\n        options?.authHandler ?? atlassianDefaultAuthHandler;\n\n      const provider = new AtlassianAuthProvider({\n        clientId,\n        clientSecret,\n        scopes,\n        callbackUrl,\n        authHandler,\n        signInResolver: options?.signIn?.resolver,\n        catalogIdentityClient,\n        logger,\n        tokenIssuer,\n      });\n\n      return OAuthAdapter.fromConfig(globalConfig, provider, {\n        providerId,\n        tokenIssuer,\n        callbackUrl,\n      });\n    });\n};\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport OAuth2Strategy from 'passport-oauth2';\n\nexport interface Auth0StrategyOptionsWithRequest {\n  clientID: string;\n  clientSecret: string;\n  callbackURL: string;\n  domain: string;\n  passReqToCallback: true;\n}\n\nexport default class Auth0Strategy extends OAuth2Strategy {\n  constructor(\n    options: Auth0StrategyOptionsWithRequest,\n    verify: OAuth2Strategy.VerifyFunctionWithRequest,\n  ) {\n    const optionsWithURLs = {\n      ...options,\n      authorizationURL: `https://${options.domain}/authorize`,\n      tokenURL: `https://${options.domain}/oauth/token`,\n      userInfoURL: `https://${options.domain}/userinfo`,\n      apiUrl: `https://${options.domain}/api`,\n    };\n    super(optionsWithURLs, verify);\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport express from 'express';\nimport passport from 'passport';\nimport Auth0Strategy from './strategy';\nimport {\n  OAuthAdapter,\n  OAuthProviderOptions,\n  OAuthHandlers,\n  OAuthResponse,\n  OAuthEnvironmentHandler,\n  OAuthStartRequest,\n  encodeState,\n  OAuthRefreshRequest,\n  OAuthResult,\n} from '../../lib/oauth';\nimport {\n  executeFetchUserProfileStrategy,\n  executeFrameHandlerStrategy,\n  executeRedirectStrategy,\n  executeRefreshTokenStrategy,\n  makeProfileInfo,\n  PassportDoneCallback,\n} from '../../lib/passport';\nimport {\n  RedirectInfo,\n  AuthProviderFactory,\n  AuthHandler,\n  SignInResolver,\n} from '../types';\nimport { CatalogIdentityClient } from '../../lib/catalog';\nimport { TokenIssuer } from '../../identity';\nimport { Logger } from 'winston';\n\ntype PrivateInfo = {\n  refreshToken: string;\n};\n\nexport type Auth0AuthProviderOptions = OAuthProviderOptions & {\n  domain: string;\n  signInResolver?: SignInResolver<OAuthResult>;\n  authHandler: AuthHandler<OAuthResult>;\n  tokenIssuer: TokenIssuer;\n  catalogIdentityClient: CatalogIdentityClient;\n  logger: Logger;\n};\n\nexport class Auth0AuthProvider implements OAuthHandlers {\n  private readonly _strategy: Auth0Strategy;\n  private readonly signInResolver?: SignInResolver<OAuthResult>;\n  private readonly authHandler: AuthHandler<OAuthResult>;\n  private readonly tokenIssuer: TokenIssuer;\n  private readonly catalogIdentityClient: CatalogIdentityClient;\n  private readonly logger: Logger;\n\n  constructor(options: Auth0AuthProviderOptions) {\n    this.signInResolver = options.signInResolver;\n    this.authHandler = options.authHandler;\n    this.tokenIssuer = options.tokenIssuer;\n    this.catalogIdentityClient = options.catalogIdentityClient;\n    this.logger = options.logger;\n    this._strategy = new Auth0Strategy(\n      {\n        clientID: options.clientId,\n        clientSecret: options.clientSecret,\n        callbackURL: options.callbackUrl,\n        domain: options.domain,\n        passReqToCallback: false as true,\n      },\n      (\n        accessToken: any,\n        refreshToken: any,\n        params: any,\n        fullProfile: passport.Profile,\n        done: PassportDoneCallback<OAuthResult, PrivateInfo>,\n      ) => {\n        done(\n          undefined,\n          {\n            fullProfile,\n            accessToken,\n            refreshToken,\n            params,\n          },\n          {\n            refreshToken,\n          },\n        );\n      },\n    );\n  }\n\n  async start(req: OAuthStartRequest): Promise<RedirectInfo> {\n    return await executeRedirectStrategy(req, this._strategy, {\n      accessType: 'offline',\n      prompt: 'consent',\n      scope: req.scope,\n      state: encodeState(req.state),\n    });\n  }\n\n  async handler(req: express.Request) {\n    const { result, privateInfo } = await executeFrameHandlerStrategy<\n      OAuthResult,\n      PrivateInfo\n    >(req, this._strategy);\n\n    return {\n      response: await this.handleResult(result),\n      refreshToken: privateInfo.refreshToken,\n    };\n  }\n\n  async refresh(req: OAuthRefreshRequest) {\n    const { accessToken, refreshToken, params } =\n      await executeRefreshTokenStrategy(\n        this._strategy,\n        req.refreshToken,\n        req.scope,\n      );\n\n    const fullProfile = await executeFetchUserProfileStrategy(\n      this._strategy,\n      accessToken,\n    );\n\n    return {\n      response: await this.handleResult({\n        fullProfile,\n        params,\n        accessToken,\n      }),\n      refreshToken,\n    };\n  }\n\n  private async handleResult(result: OAuthResult) {\n    const context = {\n      logger: this.logger,\n      catalogIdentityClient: this.catalogIdentityClient,\n      tokenIssuer: this.tokenIssuer,\n    };\n    const { profile } = await this.authHandler(result, context);\n\n    const response: OAuthResponse = {\n      providerInfo: {\n        idToken: result.params.id_token,\n        accessToken: result.accessToken,\n        scope: result.params.scope,\n        expiresInSeconds: result.params.expires_in,\n      },\n      profile,\n    };\n\n    if (this.signInResolver) {\n      response.backstageIdentity = await this.signInResolver(\n        {\n          result,\n          profile,\n        },\n        context,\n      );\n    }\n\n    return response;\n  }\n}\n\nconst defaultSignInResolver: SignInResolver<OAuthResult> = async info => {\n  const { profile } = info;\n\n  if (!profile.email) {\n    throw new Error('Profile does not contain an email');\n  }\n\n  const id = profile.email.split('@')[0];\n\n  return { id, token: '' };\n};\n\n/** @public */\nexport type Auth0ProviderOptions = {\n  /**\n   * The profile transformation function used to verify and convert the auth response\n   * into the profile that will be presented to the user.\n   */\n  authHandler?: AuthHandler<OAuthResult>;\n\n  /**\n   * Configure sign-in for this provider, without it the provider can not be used to sign users in.\n   */\n  signIn?: {\n    /**\n     * Maps an auth result to a Backstage identity for the user.\n     */\n    resolver: SignInResolver<OAuthResult>;\n  };\n};\n\n/** @public */\nexport const createAuth0Provider = (\n  options?: Auth0ProviderOptions,\n): AuthProviderFactory => {\n  return ({\n    providerId,\n    globalConfig,\n    config,\n    tokenIssuer,\n    tokenManager,\n    catalogApi,\n    logger,\n  }) =>\n    OAuthEnvironmentHandler.mapConfig(config, envConfig => {\n      const clientId = envConfig.getString('clientId');\n      const clientSecret = envConfig.getString('clientSecret');\n      const domain = envConfig.getString('domain');\n      const customCallbackUrl = envConfig.getOptionalString('callbackUrl');\n      const callbackUrl =\n        customCallbackUrl ||\n        `${globalConfig.baseUrl}/${providerId}/handler/frame`;\n\n      const catalogIdentityClient = new CatalogIdentityClient({\n        catalogApi,\n        tokenManager,\n      });\n\n      const authHandler: AuthHandler<OAuthResult> = options?.authHandler\n        ? options.authHandler\n        : async ({ fullProfile, params }) => ({\n            profile: makeProfileInfo(fullProfile, params.id_token),\n          });\n\n      const signInResolver = options?.signIn?.resolver ?? defaultSignInResolver;\n\n      const provider = new Auth0AuthProvider({\n        clientId,\n        clientSecret,\n        callbackUrl,\n        domain,\n        authHandler,\n        signInResolver,\n        tokenIssuer,\n        catalogIdentityClient,\n        logger,\n      });\n\n      return OAuthAdapter.fromConfig(globalConfig, provider, {\n        disableRefresh: true,\n        providerId,\n        tokenIssuer,\n        callbackUrl,\n      });\n    });\n};\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AuthHandler,\n  AuthProviderFactory,\n  AuthProviderRouteHandlers,\n  AuthResponse,\n  SignInResolver,\n} from '../types';\nimport express from 'express';\nimport fetch from 'node-fetch';\nimport * as crypto from 'crypto';\nimport { KeyObject } from 'crypto';\nimport { Logger } from 'winston';\nimport NodeCache from 'node-cache';\nimport { JWT } from 'jose';\nimport { TokenIssuer } from '../../identity/types';\nimport { CatalogIdentityClient } from '../../lib/catalog';\nimport { Profile as PassportProfile } from 'passport';\nimport { makeProfileInfo } from '../../lib/passport';\nimport { AuthenticationError } from '@backstage/errors';\nimport { prepareBackstageIdentityResponse } from '../prepareBackstageIdentityResponse';\n\nexport const ALB_JWT_HEADER = 'x-amzn-oidc-data';\nexport const ALB_ACCESS_TOKEN_HEADER = 'x-amzn-oidc-accesstoken';\n\ntype Options = {\n  region: string;\n  issuer?: string;\n  logger: Logger;\n  authHandler: AuthHandler<AwsAlbResult>;\n  signInResolver: SignInResolver<AwsAlbResult>;\n  tokenIssuer: TokenIssuer;\n  catalogIdentityClient: CatalogIdentityClient;\n};\n\nexport const getJWTHeaders = (input: string): AwsAlbHeaders => {\n  const encoded = input.split('.')[0];\n  return JSON.parse(Buffer.from(encoded, 'base64').toString('utf8'));\n};\n\nexport type AwsAlbHeaders = {\n  alg: string;\n  kid: string;\n  signer: string;\n  iss: string;\n  client: string;\n  exp: number;\n};\n\nexport type AwsAlbClaims = {\n  sub: string;\n  name: string;\n  family_name: string;\n  given_name: string;\n  picture: string;\n  email: string;\n  exp: number;\n  iss: string;\n};\n\nexport type AwsAlbResult = {\n  fullProfile: PassportProfile;\n  expiresInSeconds?: number;\n  accessToken: string;\n};\n\nexport type AwsAlbProviderInfo = {\n  /**\n   * An access token issued for the signed in user.\n   */\n  accessToken: string;\n  /**\n   * Expiry of the access token in seconds.\n   */\n  expiresInSeconds?: number;\n};\n\nexport type AwsAlbResponse = AuthResponse<AwsAlbProviderInfo>;\n\nexport class AwsAlbAuthProvider implements AuthProviderRouteHandlers {\n  private readonly region: string;\n  private readonly issuer?: string;\n  private readonly tokenIssuer: TokenIssuer;\n  private readonly catalogIdentityClient: CatalogIdentityClient;\n  private readonly logger: Logger;\n  private readonly keyCache: NodeCache;\n  private readonly authHandler: AuthHandler<AwsAlbResult>;\n  private readonly signInResolver: SignInResolver<AwsAlbResult>;\n\n  constructor(options: Options) {\n    this.region = options.region;\n    this.issuer = options.issuer;\n    this.authHandler = options.authHandler;\n    this.signInResolver = options.signInResolver;\n    this.tokenIssuer = options.tokenIssuer;\n    this.catalogIdentityClient = options.catalogIdentityClient;\n    this.logger = options.logger;\n    this.keyCache = new NodeCache({ stdTTL: 3600 });\n  }\n\n  frameHandler(): Promise<void> {\n    return Promise.resolve(undefined);\n  }\n\n  async refresh(req: express.Request, res: express.Response): Promise<void> {\n    try {\n      const result = await this.getResult(req);\n      const response = await this.handleResult(result);\n      res.json(response);\n    } catch (e) {\n      this.logger.error('Exception occurred during AWS ALB token refresh', e);\n      res.status(401);\n      res.end();\n    }\n  }\n\n  start(): Promise<void> {\n    return Promise.resolve(undefined);\n  }\n\n  private async getResult(req: express.Request): Promise<AwsAlbResult> {\n    const jwt = req.header(ALB_JWT_HEADER);\n    const accessToken = req.header(ALB_ACCESS_TOKEN_HEADER);\n\n    if (jwt === undefined) {\n      throw new AuthenticationError(\n        `Missing ALB OIDC header: ${ALB_JWT_HEADER}`,\n      );\n    }\n\n    if (accessToken === undefined) {\n      throw new AuthenticationError(\n        `Missing ALB OIDC header: ${ALB_ACCESS_TOKEN_HEADER}`,\n      );\n    }\n\n    try {\n      const headers = getJWTHeaders(jwt);\n      const key = await this.getKey(headers.kid);\n      const claims = JWT.verify(jwt, key) as AwsAlbClaims;\n\n      if (this.issuer && claims.iss !== this.issuer) {\n        throw new AuthenticationError('Issuer mismatch on JWT token');\n      }\n\n      const fullProfile: PassportProfile = {\n        provider: 'unknown',\n        id: claims.sub,\n        displayName: claims.name,\n        username: claims.email.split('@')[0].toLowerCase(),\n        name: {\n          familyName: claims.family_name,\n          givenName: claims.given_name,\n        },\n        emails: [{ value: claims.email.toLowerCase() }],\n        photos: [{ value: claims.picture }],\n      };\n\n      return {\n        fullProfile,\n        expiresInSeconds: claims.exp,\n        accessToken,\n      };\n    } catch (e) {\n      throw new Error(`Exception occurred during JWT processing: ${e}`);\n    }\n  }\n\n  private async handleResult(result: AwsAlbResult): Promise<AwsAlbResponse> {\n    const context = {\n      tokenIssuer: this.tokenIssuer,\n      catalogIdentityClient: this.catalogIdentityClient,\n      logger: this.logger,\n    };\n    const { profile } = await this.authHandler(result, context);\n    const backstageIdentity = await this.signInResolver(\n      {\n        result,\n        profile,\n      },\n      context,\n    );\n\n    return {\n      providerInfo: {\n        accessToken: result.accessToken,\n        expiresInSeconds: result.expiresInSeconds,\n      },\n      backstageIdentity: prepareBackstageIdentityResponse(backstageIdentity),\n      profile,\n    };\n  }\n\n  async getKey(keyId: string): Promise<KeyObject> {\n    const optionalCacheKey = this.keyCache.get<KeyObject>(keyId);\n    if (optionalCacheKey) {\n      return crypto.createPublicKey(optionalCacheKey);\n    }\n    const keyText: string = await fetch(\n      `https://public-keys.auth.elb.${this.region}.amazonaws.com/${keyId}`,\n    ).then(response => response.text());\n    const keyValue = crypto.createPublicKey(keyText);\n    this.keyCache.set(keyId, keyValue.export({ format: 'pem', type: 'spki' }));\n    return keyValue;\n  }\n}\n\nexport type AwsAlbProviderOptions = {\n  /**\n   * The profile transformation function used to verify and convert the auth response\n   * into the profile that will be presented to the user.\n   */\n  authHandler?: AuthHandler<AwsAlbResult>;\n\n  /**\n   * Configure sign-in for this provider, without it the provider can not be used to sign users in.\n   */\n  signIn: {\n    /**\n     * Maps an auth result to a Backstage identity for the user.\n     */\n    resolver: SignInResolver<AwsAlbResult>;\n  };\n};\n\nexport const createAwsAlbProvider = (\n  options?: AwsAlbProviderOptions,\n): AuthProviderFactory => {\n  return ({ config, tokenIssuer, catalogApi, logger, tokenManager }) => {\n    const region = config.getString('region');\n    const issuer = config.getOptionalString('iss');\n\n    if (options?.signIn.resolver === undefined) {\n      throw new Error(\n        'SignInResolver is required to use this authentication provider',\n      );\n    }\n\n    const catalogIdentityClient = new CatalogIdentityClient({\n      catalogApi,\n      tokenManager,\n    });\n\n    const authHandler: AuthHandler<AwsAlbResult> = options?.authHandler\n      ? options.authHandler\n      : async ({ fullProfile }) => ({\n          profile: makeProfileInfo(fullProfile),\n        });\n\n    const signInResolver = options?.signIn.resolver;\n\n    return new AwsAlbAuthProvider({\n      region,\n      issuer,\n      signInResolver,\n      authHandler,\n      tokenIssuer,\n      catalogIdentityClient,\n      logger,\n    });\n  };\n};\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport express from 'express';\nimport passport, { Profile as PassportProfile } from 'passport';\nimport { Strategy as BitbucketStrategy } from 'passport-bitbucket-oauth2';\nimport { TokenIssuer } from '../../identity/types';\nimport { CatalogIdentityClient, getEntityClaims } from '../../lib/catalog';\nimport {\n  encodeState,\n  OAuthAdapter,\n  OAuthEnvironmentHandler,\n  OAuthHandlers,\n  OAuthProviderOptions,\n  OAuthRefreshRequest,\n  OAuthResponse,\n  OAuthResult,\n  OAuthStartRequest,\n} from '../../lib/oauth';\nimport {\n  executeFetchUserProfileStrategy,\n  executeFrameHandlerStrategy,\n  executeRedirectStrategy,\n  executeRefreshTokenStrategy,\n  makeProfileInfo,\n  PassportDoneCallback,\n} from '../../lib/passport';\nimport {\n  AuthProviderFactory,\n  AuthHandler,\n  RedirectInfo,\n  SignInResolver,\n} from '../types';\nimport { Logger } from 'winston';\n\ntype PrivateInfo = {\n  refreshToken: string;\n};\n\ntype Options = OAuthProviderOptions & {\n  signInResolver?: SignInResolver<OAuthResult>;\n  authHandler: AuthHandler<BitbucketOAuthResult>;\n  tokenIssuer: TokenIssuer;\n  catalogIdentityClient: CatalogIdentityClient;\n  logger: Logger;\n};\n\nexport type BitbucketOAuthResult = {\n  fullProfile: BitbucketPassportProfile;\n  params: {\n    id_token?: string;\n    scope: string;\n    expires_in: number;\n  };\n  accessToken: string;\n  refreshToken?: string;\n};\n\nexport type BitbucketPassportProfile = PassportProfile & {\n  id?: string;\n  displayName?: string;\n  username?: string;\n  avatarUrl?: string;\n  _json?: {\n    links?: {\n      avatar?: {\n        href?: string;\n      };\n    };\n  };\n};\n\nexport class BitbucketAuthProvider implements OAuthHandlers {\n  private readonly _strategy: BitbucketStrategy;\n  private readonly signInResolver?: SignInResolver<OAuthResult>;\n  private readonly authHandler: AuthHandler<OAuthResult>;\n  private readonly tokenIssuer: TokenIssuer;\n  private readonly catalogIdentityClient: CatalogIdentityClient;\n  private readonly logger: Logger;\n\n  constructor(options: Options) {\n    this.signInResolver = options.signInResolver;\n    this.authHandler = options.authHandler;\n    this.tokenIssuer = options.tokenIssuer;\n    this.catalogIdentityClient = options.catalogIdentityClient;\n    this.logger = options.logger;\n    this._strategy = new BitbucketStrategy(\n      {\n        clientID: options.clientId,\n        clientSecret: options.clientSecret,\n        callbackURL: options.callbackUrl,\n        // We need passReqToCallback set to false to get params, but there's\n        // no matching type signature for that, so instead behold this beauty\n        passReqToCallback: false as true,\n      },\n      (\n        accessToken: any,\n        refreshToken: any,\n        params: any,\n        fullProfile: passport.Profile,\n        done: PassportDoneCallback<OAuthResult, PrivateInfo>,\n      ) => {\n        done(\n          undefined,\n          {\n            fullProfile,\n            params,\n            accessToken,\n            refreshToken,\n          },\n          {\n            refreshToken,\n          },\n        );\n      },\n    );\n  }\n\n  async start(req: OAuthStartRequest): Promise<RedirectInfo> {\n    return await executeRedirectStrategy(req, this._strategy, {\n      accessType: 'offline',\n      prompt: 'consent',\n      scope: req.scope,\n      state: encodeState(req.state),\n    });\n  }\n\n  async handler(req: express.Request) {\n    const { result, privateInfo } = await executeFrameHandlerStrategy<\n      OAuthResult,\n      PrivateInfo\n    >(req, this._strategy);\n\n    return {\n      response: await this.handleResult(result),\n      refreshToken: privateInfo.refreshToken,\n    };\n  }\n\n  async refresh(req: OAuthRefreshRequest) {\n    const { accessToken, refreshToken, params } =\n      await executeRefreshTokenStrategy(\n        this._strategy,\n        req.refreshToken,\n        req.scope,\n      );\n    const fullProfile = await executeFetchUserProfileStrategy(\n      this._strategy,\n      accessToken,\n    );\n    return {\n      response: await this.handleResult({\n        fullProfile,\n        params,\n        accessToken,\n      }),\n      refreshToken,\n    };\n  }\n\n  private async handleResult(result: BitbucketOAuthResult) {\n    result.fullProfile.avatarUrl =\n      result.fullProfile._json!.links!.avatar!.href;\n    const context = {\n      logger: this.logger,\n      catalogIdentityClient: this.catalogIdentityClient,\n      tokenIssuer: this.tokenIssuer,\n    };\n    const { profile } = await this.authHandler(result, context);\n\n    const response: OAuthResponse = {\n      providerInfo: {\n        idToken: result.params.id_token,\n        accessToken: result.accessToken,\n        scope: result.params.scope,\n        expiresInSeconds: result.params.expires_in,\n      },\n      profile,\n    };\n\n    if (this.signInResolver) {\n      response.backstageIdentity = await this.signInResolver(\n        {\n          result,\n          profile,\n        },\n        context,\n      );\n    }\n\n    return response;\n  }\n}\n\nexport const bitbucketUsernameSignInResolver: SignInResolver<\n  BitbucketOAuthResult\n> = async (info, ctx) => {\n  const { result } = info;\n\n  if (!result.fullProfile.username) {\n    throw new Error('Bitbucket profile contained no Username');\n  }\n\n  const entity = await ctx.catalogIdentityClient.findUser({\n    annotations: {\n      'bitbucket.org/username': result.fullProfile.username,\n    },\n  });\n\n  const claims = getEntityClaims(entity);\n  const token = await ctx.tokenIssuer.issueToken({ claims });\n\n  return { id: entity.metadata.name, entity, token };\n};\n\nexport const bitbucketUserIdSignInResolver: SignInResolver<\n  BitbucketOAuthResult\n> = async (info, ctx) => {\n  const { result } = info;\n\n  if (!result.fullProfile.id) {\n    throw new Error('Bitbucket profile contained no User ID');\n  }\n\n  const entity = await ctx.catalogIdentityClient.findUser({\n    annotations: {\n      'bitbucket.org/user-id': result.fullProfile.id,\n    },\n  });\n\n  const claims = getEntityClaims(entity);\n  const token = await ctx.tokenIssuer.issueToken({ claims });\n\n  return { id: entity.metadata.name, entity, token };\n};\n\nexport type BitbucketProviderOptions = {\n  /**\n   * The profile transformation function used to verify and convert the auth response\n   * into the profile that will be presented to the user.\n   */\n  authHandler?: AuthHandler<OAuthResult>;\n\n  /**\n   * Configure sign-in for this provider, without it the provider can not be used to sign users in.\n   */\n  signIn?: {\n    /**\n     * Maps an auth result to a Backstage identity for the user.\n     */\n    resolver: SignInResolver<OAuthResult>;\n  };\n};\n\nexport const createBitbucketProvider = (\n  options?: BitbucketProviderOptions,\n): AuthProviderFactory => {\n  return ({\n    providerId,\n    globalConfig,\n    config,\n    tokenIssuer,\n    tokenManager,\n    catalogApi,\n    logger,\n  }) =>\n    OAuthEnvironmentHandler.mapConfig(config, envConfig => {\n      const clientId = envConfig.getString('clientId');\n      const clientSecret = envConfig.getString('clientSecret');\n      const customCallbackUrl = envConfig.getOptionalString('callbackUrl');\n      const callbackUrl =\n        customCallbackUrl ||\n        `${globalConfig.baseUrl}/${providerId}/handler/frame`;\n\n      const catalogIdentityClient = new CatalogIdentityClient({\n        catalogApi,\n        tokenManager,\n      });\n\n      const authHandler: AuthHandler<BitbucketOAuthResult> =\n        options?.authHandler\n          ? options.authHandler\n          : async ({ fullProfile, params }) => ({\n              profile: makeProfileInfo(fullProfile, params.id_token),\n            });\n\n      const provider = new BitbucketAuthProvider({\n        clientId,\n        clientSecret,\n        callbackUrl,\n        signInResolver: options?.signIn?.resolver,\n        authHandler,\n        tokenIssuer,\n        catalogIdentityClient,\n        logger,\n      });\n\n      return OAuthAdapter.fromConfig(globalConfig, provider, {\n        disableRefresh: false,\n        providerId,\n        tokenIssuer,\n        callbackUrl,\n      });\n    });\n};\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DEFAULT_NAMESPACE,\n  stringifyEntityRef,\n} from '@backstage/catalog-model';\nimport express from 'express';\nimport { Logger } from 'winston';\nimport { Profile as PassportProfile } from 'passport';\nimport { Strategy as GithubStrategy } from 'passport-github2';\nimport {\n  executeFetchUserProfileStrategy,\n  executeFrameHandlerStrategy,\n  executeRedirectStrategy,\n  executeRefreshTokenStrategy,\n  makeProfileInfo,\n  PassportDoneCallback,\n} from '../../lib/passport';\nimport {\n  RedirectInfo,\n  AuthProviderFactory,\n  AuthHandler,\n  SignInResolver,\n  StateEncoder,\n} from '../types';\nimport {\n  OAuthAdapter,\n  OAuthProviderOptions,\n  OAuthHandlers,\n  OAuthEnvironmentHandler,\n  OAuthStartRequest,\n  encodeState,\n  OAuthRefreshRequest,\n} from '../../lib/oauth';\nimport { CatalogIdentityClient } from '../../lib/catalog';\nimport { TokenIssuer } from '../../identity';\n\nconst ACCESS_TOKEN_PREFIX = 'access-token.';\n\n// TODO(Rugvip): Auth providers need a way to access this in a less hardcoded way\nconst BACKSTAGE_SESSION_EXPIRATION = 3600;\n\ntype PrivateInfo = {\n  refreshToken?: string;\n};\n\nexport type GithubOAuthResult = {\n  fullProfile: PassportProfile;\n  params: {\n    scope: string;\n    expires_in?: string;\n    refresh_token_expires_in?: string;\n  };\n  accessToken: string;\n  refreshToken?: string;\n};\n\nexport type GithubAuthProviderOptions = OAuthProviderOptions & {\n  tokenUrl?: string;\n  userProfileUrl?: string;\n  authorizationUrl?: string;\n  signInResolver?: SignInResolver<GithubOAuthResult>;\n  authHandler: AuthHandler<GithubOAuthResult>;\n  stateEncoder: StateEncoder;\n  tokenIssuer: TokenIssuer;\n  catalogIdentityClient: CatalogIdentityClient;\n  logger: Logger;\n};\n\nexport class GithubAuthProvider implements OAuthHandlers {\n  private readonly _strategy: GithubStrategy;\n  private readonly signInResolver?: SignInResolver<GithubOAuthResult>;\n  private readonly authHandler: AuthHandler<GithubOAuthResult>;\n  private readonly tokenIssuer: TokenIssuer;\n  private readonly catalogIdentityClient: CatalogIdentityClient;\n  private readonly logger: Logger;\n  private readonly stateEncoder: StateEncoder;\n\n  constructor(options: GithubAuthProviderOptions) {\n    this.signInResolver = options.signInResolver;\n    this.authHandler = options.authHandler;\n    this.stateEncoder = options.stateEncoder;\n    this.tokenIssuer = options.tokenIssuer;\n    this.catalogIdentityClient = options.catalogIdentityClient;\n    this.logger = options.logger;\n    this._strategy = new GithubStrategy(\n      {\n        clientID: options.clientId,\n        clientSecret: options.clientSecret,\n        callbackURL: options.callbackUrl,\n        tokenURL: options.tokenUrl,\n        userProfileURL: options.userProfileUrl,\n        authorizationURL: options.authorizationUrl,\n      },\n      (\n        accessToken: any,\n        refreshToken: any,\n        params: any,\n        fullProfile: any,\n        done: PassportDoneCallback<GithubOAuthResult, PrivateInfo>,\n      ) => {\n        done(undefined, { fullProfile, params, accessToken }, { refreshToken });\n      },\n    );\n  }\n\n  async start(req: OAuthStartRequest): Promise<RedirectInfo> {\n    return await executeRedirectStrategy(req, this._strategy, {\n      scope: req.scope,\n      state: (await this.stateEncoder(req)).encodedState,\n    });\n  }\n\n  async handler(req: express.Request) {\n    const { result, privateInfo } = await executeFrameHandlerStrategy<\n      GithubOAuthResult,\n      PrivateInfo\n    >(req, this._strategy);\n\n    let refreshToken = privateInfo.refreshToken;\n\n    // If we do not have a real refresh token and we have a non-expiring\n    // access token, then we use that as our refresh token.\n    if (!refreshToken && !result.params.expires_in) {\n      refreshToken = ACCESS_TOKEN_PREFIX + result.accessToken;\n    }\n\n    return {\n      response: await this.handleResult(result),\n      refreshToken,\n    };\n  }\n\n  async refresh(req: OAuthRefreshRequest) {\n    // We've enable persisting scope in the OAuth provider, so scope here will\n    // be whatever was stored in the cookie\n    const { scope, refreshToken } = req;\n\n    // This is the OAuth App flow. A non-expiring access token is stored in the\n    // refresh token cookie. We use that token to fetch the user profile and\n    // refresh the Backstage session when needed.\n    if (refreshToken?.startsWith(ACCESS_TOKEN_PREFIX)) {\n      const accessToken = refreshToken.slice(ACCESS_TOKEN_PREFIX.length);\n\n      const fullProfile = await executeFetchUserProfileStrategy(\n        this._strategy,\n        accessToken,\n      ).catch(error => {\n        if (error.oauthError?.statusCode === 401) {\n          throw new Error('Invalid access token');\n        }\n        throw error;\n      });\n\n      return {\n        response: await this.handleResult({\n          fullProfile,\n          params: { scope },\n          accessToken,\n        }),\n        refreshToken,\n      };\n    }\n\n    // This is the App flow, which is close to a standard OAuth refresh flow. It has a\n    // pretty long session expiration, and it also ignores the requested scope, instead\n    // just allowing access to whatever is configured as part of the app installation.\n    const result = await executeRefreshTokenStrategy(\n      this._strategy,\n      refreshToken,\n      scope,\n    );\n    return {\n      response: await this.handleResult({\n        fullProfile: await executeFetchUserProfileStrategy(\n          this._strategy,\n          result.accessToken,\n        ),\n        params: { ...result.params, scope },\n        accessToken: result.accessToken,\n      }),\n      refreshToken: result.refreshToken,\n    };\n  }\n\n  private async handleResult(result: GithubOAuthResult) {\n    const context = {\n      logger: this.logger,\n      catalogIdentityClient: this.catalogIdentityClient,\n      tokenIssuer: this.tokenIssuer,\n    };\n    const { profile } = await this.authHandler(result, context);\n\n    const expiresInStr = result.params.expires_in;\n    let expiresInSeconds =\n      expiresInStr === undefined ? undefined : Number(expiresInStr);\n\n    let backstageIdentity = undefined;\n\n    if (this.signInResolver) {\n      backstageIdentity = await this.signInResolver(\n        {\n          result,\n          profile,\n        },\n        context,\n      );\n\n      // GitHub sessions last longer than Backstage sessions, so if we're using\n      // GitHub for sign-in, then we need to expire the sessions earlier\n      if (expiresInSeconds) {\n        expiresInSeconds = Math.min(\n          expiresInSeconds,\n          BACKSTAGE_SESSION_EXPIRATION,\n        );\n      } else {\n        expiresInSeconds = BACKSTAGE_SESSION_EXPIRATION;\n      }\n    }\n\n    return {\n      backstageIdentity,\n      providerInfo: {\n        accessToken: result.accessToken,\n        scope: result.params.scope,\n        expiresInSeconds,\n      },\n      profile,\n    };\n  }\n}\n\nexport const githubDefaultSignInResolver: SignInResolver<\n  GithubOAuthResult\n> = async (info, ctx) => {\n  const { fullProfile } = info.result;\n\n  const userId = fullProfile.username || fullProfile.id;\n\n  const entityRef = stringifyEntityRef({\n    kind: 'User',\n    namespace: DEFAULT_NAMESPACE,\n    name: userId,\n  });\n\n  const token = await ctx.tokenIssuer.issueToken({\n    claims: {\n      sub: entityRef,\n      ent: [entityRef],\n    },\n  });\n\n  return { id: userId, token };\n};\n\nexport type GithubProviderOptions = {\n  /**\n   * The profile transformation function used to verify and convert the auth response\n   * into the profile that will be presented to the user.\n   */\n  authHandler?: AuthHandler<GithubOAuthResult>;\n\n  /**\n   * Configure sign-in for this provider, without it the provider can not be used to sign users in.\n   */\n  signIn?: {\n    /**\n     * Maps an auth result to a Backstage identity for the user.\n     */\n    resolver?: SignInResolver<GithubOAuthResult>;\n  };\n\n  /**\n   * The state encoder used to encode the 'state' parameter on the OAuth request.\n   *\n   * It should return a string that takes the state params (from the request), url encodes the params\n   * and finally base64 encodes them.\n   *\n   * Providing your own stateEncoder will allow you to add addition parameters to the state field.\n   *\n   * It is typed as follows:\n   *   `export type StateEncoder = (input: OAuthState) => Promise<{encodedState: string}>;`\n   *\n   * Note: the stateEncoder must encode a 'nonce' value and an 'env' value. Without this, the OAuth flow will fail\n   * (These two values will be set by the req.state by default)\n   *\n   * For more information, please see the helper module in ../../oauth/helpers #readState\n   */\n  stateEncoder?: StateEncoder;\n};\n\nexport const createGithubProvider = (\n  options?: GithubProviderOptions,\n): AuthProviderFactory => {\n  return ({\n    providerId,\n    globalConfig,\n    config,\n    tokenIssuer,\n    tokenManager,\n    catalogApi,\n    logger,\n  }) =>\n    OAuthEnvironmentHandler.mapConfig(config, envConfig => {\n      const clientId = envConfig.getString('clientId');\n      const clientSecret = envConfig.getString('clientSecret');\n      const enterpriseInstanceUrl = envConfig.getOptionalString(\n        'enterpriseInstanceUrl',\n      );\n      const customCallbackUrl = envConfig.getOptionalString('callbackUrl');\n      const authorizationUrl = enterpriseInstanceUrl\n        ? `${enterpriseInstanceUrl}/login/oauth/authorize`\n        : undefined;\n      const tokenUrl = enterpriseInstanceUrl\n        ? `${enterpriseInstanceUrl}/login/oauth/access_token`\n        : undefined;\n      const userProfileUrl = enterpriseInstanceUrl\n        ? `${enterpriseInstanceUrl}/api/v3/user`\n        : undefined;\n      const callbackUrl =\n        customCallbackUrl ||\n        `${globalConfig.baseUrl}/${providerId}/handler/frame`;\n\n      const catalogIdentityClient = new CatalogIdentityClient({\n        catalogApi,\n        tokenManager,\n      });\n\n      const authHandler: AuthHandler<GithubOAuthResult> = options?.authHandler\n        ? options.authHandler\n        : async ({ fullProfile }) => ({\n            profile: makeProfileInfo(fullProfile),\n          });\n\n      const signInResolverFn =\n        options?.signIn?.resolver ?? githubDefaultSignInResolver;\n\n      const signInResolver: SignInResolver<GithubOAuthResult> = info =>\n        signInResolverFn(info, {\n          catalogIdentityClient,\n          tokenIssuer,\n          logger,\n        });\n\n      const stateEncoder: StateEncoder =\n        options?.stateEncoder ??\n        (async (req: OAuthStartRequest): Promise<{ encodedState: string }> => {\n          return { encodedState: encodeState(req.state) };\n        });\n\n      const provider = new GithubAuthProvider({\n        clientId,\n        clientSecret,\n        callbackUrl,\n        tokenUrl,\n        userProfileUrl,\n        authorizationUrl,\n        signInResolver,\n        authHandler,\n        tokenIssuer,\n        catalogIdentityClient,\n        stateEncoder,\n        logger,\n      });\n\n      return OAuthAdapter.fromConfig(globalConfig, provider, {\n        persistScopes: true,\n        providerId,\n        tokenIssuer,\n        callbackUrl,\n      });\n    });\n};\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DEFAULT_NAMESPACE,\n  stringifyEntityRef,\n} from '@backstage/catalog-model';\nimport express from 'express';\nimport { Strategy as GitlabStrategy } from 'passport-gitlab2';\nimport { Logger } from 'winston';\nimport {\n  executeRedirectStrategy,\n  executeFrameHandlerStrategy,\n  executeRefreshTokenStrategy,\n  executeFetchUserProfileStrategy,\n  makeProfileInfo,\n  PassportDoneCallback,\n} from '../../lib/passport';\nimport {\n  RedirectInfo,\n  AuthProviderFactory,\n  SignInResolver,\n  AuthHandler,\n} from '../types';\nimport {\n  OAuthAdapter,\n  OAuthProviderOptions,\n  OAuthHandlers,\n  OAuthResponse,\n  OAuthEnvironmentHandler,\n  OAuthStartRequest,\n  OAuthRefreshRequest,\n  encodeState,\n  OAuthResult,\n} from '../../lib/oauth';\nimport { TokenIssuer } from '../../identity';\nimport { CatalogIdentityClient } from '../../lib/catalog';\n\ntype PrivateInfo = {\n  refreshToken: string;\n};\n\nexport type GitlabAuthProviderOptions = OAuthProviderOptions & {\n  baseUrl: string;\n  signInResolver?: SignInResolver<OAuthResult>;\n  authHandler: AuthHandler<OAuthResult>;\n  tokenIssuer: TokenIssuer;\n  catalogIdentityClient: CatalogIdentityClient;\n  logger: Logger;\n};\n\nexport const gitlabDefaultSignInResolver: SignInResolver<OAuthResult> = async (\n  info,\n  ctx,\n) => {\n  const { profile, result } = info;\n\n  let id = result.fullProfile.id;\n\n  if (profile.email) {\n    id = profile.email.split('@')[0];\n  }\n\n  const entityRef = stringifyEntityRef({\n    kind: 'User',\n    namespace: DEFAULT_NAMESPACE,\n    name: id,\n  });\n\n  const token = await ctx.tokenIssuer.issueToken({\n    claims: {\n      sub: entityRef,\n      ent: [entityRef],\n    },\n  });\n\n  return { id, token };\n};\n\nexport const gitlabDefaultAuthHandler: AuthHandler<OAuthResult> = async ({\n  fullProfile,\n  params,\n}) => ({\n  profile: makeProfileInfo(fullProfile, params.id_token),\n});\n\nexport class GitlabAuthProvider implements OAuthHandlers {\n  private readonly _strategy: GitlabStrategy;\n  private readonly signInResolver?: SignInResolver<OAuthResult>;\n  private readonly authHandler: AuthHandler<OAuthResult>;\n  private readonly tokenIssuer: TokenIssuer;\n  private readonly catalogIdentityClient: CatalogIdentityClient;\n  private readonly logger: Logger;\n\n  constructor(options: GitlabAuthProviderOptions) {\n    this.catalogIdentityClient = options.catalogIdentityClient;\n    this.logger = options.logger;\n    this.tokenIssuer = options.tokenIssuer;\n    this.authHandler = options.authHandler;\n    this.signInResolver = options.signInResolver;\n\n    this._strategy = new GitlabStrategy(\n      {\n        clientID: options.clientId,\n        clientSecret: options.clientSecret,\n        callbackURL: options.callbackUrl,\n        baseURL: options.baseUrl,\n      },\n      (\n        accessToken: any,\n        refreshToken: any,\n        params: any,\n        fullProfile: any,\n        done: PassportDoneCallback<OAuthResult, PrivateInfo>,\n      ) => {\n        done(\n          undefined,\n          { fullProfile, params, accessToken },\n          {\n            refreshToken,\n          },\n        );\n      },\n    );\n  }\n\n  async start(req: OAuthStartRequest): Promise<RedirectInfo> {\n    return await executeRedirectStrategy(req, this._strategy, {\n      scope: req.scope,\n      state: encodeState(req.state),\n    });\n  }\n\n  async handler(req: express.Request) {\n    const { result, privateInfo } = await executeFrameHandlerStrategy<\n      OAuthResult,\n      PrivateInfo\n    >(req, this._strategy);\n\n    return {\n      response: await this.handleResult(result),\n      refreshToken: privateInfo.refreshToken,\n    };\n  }\n\n  async refresh(req: OAuthRefreshRequest) {\n    const { accessToken, refreshToken, params } =\n      await executeRefreshTokenStrategy(\n        this._strategy,\n        req.refreshToken,\n        req.scope,\n      );\n\n    const fullProfile = await executeFetchUserProfileStrategy(\n      this._strategy,\n      accessToken,\n    );\n    return {\n      response: await this.handleResult({\n        fullProfile,\n        params,\n        accessToken,\n      }),\n      refreshToken,\n    };\n  }\n\n  private async handleResult(result: OAuthResult): Promise<OAuthResponse> {\n    const context = {\n      logger: this.logger,\n      catalogIdentityClient: this.catalogIdentityClient,\n      tokenIssuer: this.tokenIssuer,\n    };\n    const { profile } = await this.authHandler(result, context);\n\n    const response: OAuthResponse = {\n      providerInfo: {\n        idToken: result.params.id_token,\n        accessToken: result.accessToken,\n        scope: result.params.scope,\n        expiresInSeconds: result.params.expires_in,\n      },\n      profile,\n    };\n\n    if (this.signInResolver) {\n      response.backstageIdentity = await this.signInResolver(\n        {\n          result,\n          profile,\n        },\n        context,\n      );\n    }\n\n    return response;\n  }\n}\n\nexport type GitlabProviderOptions = {\n  /**\n   * The profile transformation function used to verify and convert the auth response\n   * into the profile that will be presented to the user.\n   */\n  authHandler?: AuthHandler<OAuthResult>;\n\n  /**\n   * Configure sign-in for this provider, without it the provider can not be used to sign users in.\n   */\n  /**\n   * Maps an auth result to a Backstage identity for the user.\n   *\n   * Set to `'email'` to use the default email-based sign in resolver, which will search\n   * the catalog for a single user entity that has a matching `microsoft.com/email` annotation.\n   */\n  signIn?: {\n    resolver?: SignInResolver<OAuthResult>;\n  };\n};\n\nexport const createGitlabProvider = (\n  options?: GitlabProviderOptions,\n): AuthProviderFactory => {\n  return ({\n    providerId,\n    globalConfig,\n    config,\n    tokenIssuer,\n    tokenManager,\n    catalogApi,\n    logger,\n  }) =>\n    OAuthEnvironmentHandler.mapConfig(config, envConfig => {\n      const clientId = envConfig.getString('clientId');\n      const clientSecret = envConfig.getString('clientSecret');\n      const audience = envConfig.getOptionalString('audience');\n      const baseUrl = audience || 'https://gitlab.com';\n      const customCallbackUrl = envConfig.getOptionalString('callbackUrl');\n      const callbackUrl =\n        customCallbackUrl ||\n        `${globalConfig.baseUrl}/${providerId}/handler/frame`;\n\n      const catalogIdentityClient = new CatalogIdentityClient({\n        catalogApi,\n        tokenManager,\n      });\n\n      const authHandler: AuthHandler<OAuthResult> =\n        options?.authHandler ?? gitlabDefaultAuthHandler;\n\n      const signInResolverFn =\n        options?.signIn?.resolver ?? gitlabDefaultSignInResolver;\n\n      const signInResolver: SignInResolver<OAuthResult> = info =>\n        signInResolverFn(info, {\n          catalogIdentityClient,\n          tokenIssuer,\n          logger,\n        });\n\n      const provider = new GitlabAuthProvider({\n        clientId,\n        clientSecret,\n        callbackUrl,\n        baseUrl,\n        authHandler,\n        signInResolver,\n        catalogIdentityClient,\n        logger,\n        tokenIssuer,\n      });\n\n      return OAuthAdapter.fromConfig(globalConfig, provider, {\n        disableRefresh: false,\n        providerId,\n        tokenIssuer,\n        callbackUrl,\n      });\n    });\n};\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DEFAULT_NAMESPACE,\n  stringifyEntityRef,\n} from '@backstage/catalog-model';\nimport express from 'express';\nimport passport from 'passport';\nimport { Strategy as GoogleStrategy } from 'passport-google-oauth20';\nimport { TokenIssuer } from '../../identity/types';\nimport { CatalogIdentityClient, getEntityClaims } from '../../lib/catalog';\nimport {\n  encodeState,\n  OAuthAdapter,\n  OAuthEnvironmentHandler,\n  OAuthHandlers,\n  OAuthProviderOptions,\n  OAuthRefreshRequest,\n  OAuthResponse,\n  OAuthResult,\n  OAuthStartRequest,\n} from '../../lib/oauth';\nimport {\n  executeFetchUserProfileStrategy,\n  executeFrameHandlerStrategy,\n  executeRedirectStrategy,\n  executeRefreshTokenStrategy,\n  makeProfileInfo,\n  PassportDoneCallback,\n} from '../../lib/passport';\nimport {\n  AuthProviderFactory,\n  AuthHandler,\n  RedirectInfo,\n  SignInResolver,\n} from '../types';\nimport { Logger } from 'winston';\n\ntype PrivateInfo = {\n  refreshToken: string;\n};\n\ntype Options = OAuthProviderOptions & {\n  signInResolver?: SignInResolver<OAuthResult>;\n  authHandler: AuthHandler<OAuthResult>;\n  tokenIssuer: TokenIssuer;\n  catalogIdentityClient: CatalogIdentityClient;\n  logger: Logger;\n};\n\nexport class GoogleAuthProvider implements OAuthHandlers {\n  private readonly _strategy: GoogleStrategy;\n  private readonly signInResolver?: SignInResolver<OAuthResult>;\n  private readonly authHandler: AuthHandler<OAuthResult>;\n  private readonly tokenIssuer: TokenIssuer;\n  private readonly catalogIdentityClient: CatalogIdentityClient;\n  private readonly logger: Logger;\n\n  constructor(options: Options) {\n    this.signInResolver = options.signInResolver;\n    this.authHandler = options.authHandler;\n    this.tokenIssuer = options.tokenIssuer;\n    this.catalogIdentityClient = options.catalogIdentityClient;\n    this.logger = options.logger;\n    this._strategy = new GoogleStrategy(\n      {\n        clientID: options.clientId,\n        clientSecret: options.clientSecret,\n        callbackURL: options.callbackUrl,\n        // We need passReqToCallback set to false to get params, but there's\n        // no matching type signature for that, so instead behold this beauty\n        passReqToCallback: false as true,\n      },\n      (\n        accessToken: any,\n        refreshToken: any,\n        params: any,\n        fullProfile: passport.Profile,\n        done: PassportDoneCallback<OAuthResult, PrivateInfo>,\n      ) => {\n        done(\n          undefined,\n          {\n            fullProfile,\n            params,\n            accessToken,\n            refreshToken,\n          },\n          {\n            refreshToken,\n          },\n        );\n      },\n    );\n  }\n\n  async start(req: OAuthStartRequest): Promise<RedirectInfo> {\n    return await executeRedirectStrategy(req, this._strategy, {\n      accessType: 'offline',\n      prompt: 'consent',\n      scope: req.scope,\n      state: encodeState(req.state),\n    });\n  }\n\n  async handler(req: express.Request) {\n    const { result, privateInfo } = await executeFrameHandlerStrategy<\n      OAuthResult,\n      PrivateInfo\n    >(req, this._strategy);\n\n    return {\n      response: await this.handleResult(result),\n      refreshToken: privateInfo.refreshToken,\n    };\n  }\n\n  async refresh(req: OAuthRefreshRequest) {\n    const { accessToken, refreshToken, params } =\n      await executeRefreshTokenStrategy(\n        this._strategy,\n        req.refreshToken,\n        req.scope,\n      );\n    const fullProfile = await executeFetchUserProfileStrategy(\n      this._strategy,\n      accessToken,\n    );\n\n    return {\n      response: await this.handleResult({\n        fullProfile,\n        params,\n        accessToken,\n      }),\n      refreshToken,\n    };\n  }\n\n  private async handleResult(result: OAuthResult) {\n    const context = {\n      logger: this.logger,\n      catalogIdentityClient: this.catalogIdentityClient,\n      tokenIssuer: this.tokenIssuer,\n    };\n    const { profile } = await this.authHandler(result, context);\n\n    const response: OAuthResponse = {\n      providerInfo: {\n        idToken: result.params.id_token,\n        accessToken: result.accessToken,\n        scope: result.params.scope,\n        expiresInSeconds: result.params.expires_in,\n      },\n      profile,\n    };\n\n    if (this.signInResolver) {\n      response.backstageIdentity = await this.signInResolver(\n        {\n          result,\n          profile,\n        },\n        context,\n      );\n    }\n\n    return response;\n  }\n}\n\nexport const googleEmailSignInResolver: SignInResolver<OAuthResult> = async (\n  info,\n  ctx,\n) => {\n  const { profile } = info;\n\n  if (!profile.email) {\n    throw new Error('Google profile contained no email');\n  }\n\n  const entity = await ctx.catalogIdentityClient.findUser({\n    annotations: {\n      'google.com/email': profile.email,\n    },\n  });\n\n  const claims = getEntityClaims(entity);\n  const token = await ctx.tokenIssuer.issueToken({ claims });\n\n  return { id: entity.metadata.name, entity, token };\n};\n\nconst googleDefaultSignInResolver: SignInResolver<OAuthResult> = async (\n  info,\n  ctx,\n) => {\n  const { profile } = info;\n\n  if (!profile.email) {\n    throw new Error('Google profile contained no email');\n  }\n\n  let userId: string;\n  try {\n    const entity = await ctx.catalogIdentityClient.findUser({\n      annotations: {\n        'google.com/email': profile.email,\n      },\n    });\n    userId = entity.metadata.name;\n  } catch (error) {\n    ctx.logger.warn(\n      `Failed to look up user, ${error}, falling back to allowing login based on email pattern, this will probably break in the future`,\n    );\n    userId = profile.email.split('@')[0];\n  }\n\n  const entityRef = stringifyEntityRef({\n    kind: 'User',\n    namespace: DEFAULT_NAMESPACE,\n    name: userId,\n  });\n\n  const token = await ctx.tokenIssuer.issueToken({\n    claims: {\n      sub: entityRef,\n      ent: [entityRef],\n    },\n  });\n\n  return { id: userId, token };\n};\n\nexport type GoogleProviderOptions = {\n  /**\n   * The profile transformation function used to verify and convert the auth response\n   * into the profile that will be presented to the user.\n   */\n  authHandler?: AuthHandler<OAuthResult>;\n\n  /**\n   * Configure sign-in for this provider, without it the provider can not be used to sign users in.\n   */\n  signIn?: {\n    /**\n     * Maps an auth result to a Backstage identity for the user.\n     */\n    resolver?: SignInResolver<OAuthResult>;\n  };\n};\n\nexport const createGoogleProvider = (\n  options?: GoogleProviderOptions,\n): AuthProviderFactory => {\n  return ({\n    providerId,\n    globalConfig,\n    config,\n    tokenIssuer,\n    tokenManager,\n    catalogApi,\n    logger,\n  }) =>\n    OAuthEnvironmentHandler.mapConfig(config, envConfig => {\n      const clientId = envConfig.getString('clientId');\n      const clientSecret = envConfig.getString('clientSecret');\n      const customCallbackUrl = envConfig.getOptionalString('callbackUrl');\n      const callbackUrl =\n        customCallbackUrl ||\n        `${globalConfig.baseUrl}/${providerId}/handler/frame`;\n\n      const catalogIdentityClient = new CatalogIdentityClient({\n        catalogApi,\n        tokenManager,\n      });\n\n      const authHandler: AuthHandler<OAuthResult> = options?.authHandler\n        ? options.authHandler\n        : async ({ fullProfile, params }) => ({\n            profile: makeProfileInfo(fullProfile, params.id_token),\n          });\n\n      const signInResolverFn =\n        options?.signIn?.resolver ?? googleDefaultSignInResolver;\n\n      const signInResolver: SignInResolver<OAuthResult> = info =>\n        signInResolverFn(info, {\n          catalogIdentityClient,\n          tokenIssuer,\n          logger,\n        });\n\n      const provider = new GoogleAuthProvider({\n        clientId,\n        clientSecret,\n        callbackUrl,\n        signInResolver,\n        authHandler,\n        tokenIssuer,\n        catalogIdentityClient,\n        logger,\n      });\n\n      return OAuthAdapter.fromConfig(globalConfig, provider, {\n        disableRefresh: false,\n        providerId,\n        tokenIssuer,\n        callbackUrl,\n      });\n    });\n};\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DEFAULT_NAMESPACE,\n  stringifyEntityRef,\n} from '@backstage/catalog-model';\nimport express from 'express';\nimport passport from 'passport';\nimport { Strategy as MicrosoftStrategy } from 'passport-microsoft';\nimport { TokenIssuer } from '../../identity/types';\nimport { CatalogIdentityClient, getEntityClaims } from '../../lib/catalog';\nimport {\n  encodeState,\n  OAuthAdapter,\n  OAuthEnvironmentHandler,\n  OAuthHandlers,\n  OAuthProviderOptions,\n  OAuthRefreshRequest,\n  OAuthResponse,\n  OAuthResult,\n  OAuthStartRequest,\n} from '../../lib/oauth';\nimport {\n  executeFetchUserProfileStrategy,\n  executeFrameHandlerStrategy,\n  executeRedirectStrategy,\n  executeRefreshTokenStrategy,\n  makeProfileInfo,\n  PassportDoneCallback,\n} from '../../lib/passport';\nimport {\n  AuthProviderFactory,\n  AuthHandler,\n  RedirectInfo,\n  SignInResolver,\n} from '../types';\nimport { Logger } from 'winston';\nimport fetch from 'node-fetch';\n\ntype PrivateInfo = {\n  refreshToken: string;\n};\n\ntype Options = OAuthProviderOptions & {\n  signInResolver?: SignInResolver<OAuthResult>;\n  authHandler: AuthHandler<OAuthResult>;\n  tokenIssuer: TokenIssuer;\n  catalogIdentityClient: CatalogIdentityClient;\n  logger: Logger;\n  authorizationUrl?: string;\n  tokenUrl?: string;\n};\n\nexport class MicrosoftAuthProvider implements OAuthHandlers {\n  private readonly _strategy: MicrosoftStrategy;\n  private readonly signInResolver?: SignInResolver<OAuthResult>;\n  private readonly authHandler: AuthHandler<OAuthResult>;\n  private readonly tokenIssuer: TokenIssuer;\n  private readonly catalogIdentityClient: CatalogIdentityClient;\n  private readonly logger: Logger;\n\n  constructor(options: Options) {\n    this.signInResolver = options.signInResolver;\n    this.authHandler = options.authHandler;\n    this.tokenIssuer = options.tokenIssuer;\n    this.logger = options.logger;\n    this.catalogIdentityClient = options.catalogIdentityClient;\n\n    this._strategy = new MicrosoftStrategy(\n      {\n        clientID: options.clientId,\n        clientSecret: options.clientSecret,\n        callbackURL: options.callbackUrl,\n        authorizationURL: options.authorizationUrl,\n        tokenURL: options.tokenUrl,\n        passReqToCallback: false as true,\n      },\n      (\n        accessToken: any,\n        refreshToken: any,\n        params: any,\n        fullProfile: passport.Profile,\n        done: PassportDoneCallback<OAuthResult, PrivateInfo>,\n      ) => {\n        done(undefined, { fullProfile, accessToken, params }, { refreshToken });\n      },\n    );\n  }\n\n  async start(req: OAuthStartRequest): Promise<RedirectInfo> {\n    return await executeRedirectStrategy(req, this._strategy, {\n      scope: req.scope,\n      state: encodeState(req.state),\n    });\n  }\n\n  async handler(req: express.Request) {\n    const { result, privateInfo } = await executeFrameHandlerStrategy<\n      OAuthResult,\n      PrivateInfo\n    >(req, this._strategy);\n\n    return {\n      response: await this.handleResult(result),\n      refreshToken: privateInfo.refreshToken,\n    };\n  }\n\n  async refresh(req: OAuthRefreshRequest) {\n    const { accessToken, refreshToken, params } =\n      await executeRefreshTokenStrategy(\n        this._strategy,\n        req.refreshToken,\n        req.scope,\n      );\n\n    const fullProfile = await executeFetchUserProfileStrategy(\n      this._strategy,\n      accessToken,\n    );\n\n    return {\n      response: await this.handleResult({\n        fullProfile,\n        params,\n        accessToken,\n      }),\n      refreshToken,\n    };\n  }\n\n  private async handleResult(result: OAuthResult) {\n    const photo = await this.getUserPhoto(result.accessToken);\n    result.fullProfile.photos = photo ? [{ value: photo }] : undefined;\n\n    const context = {\n      logger: this.logger,\n      catalogIdentityClient: this.catalogIdentityClient,\n      tokenIssuer: this.tokenIssuer,\n    };\n    const { profile } = await this.authHandler(result, context);\n\n    const response: OAuthResponse = {\n      providerInfo: {\n        idToken: result.params.id_token,\n        accessToken: result.accessToken,\n        scope: result.params.scope,\n        expiresInSeconds: result.params.expires_in,\n      },\n      profile,\n    };\n\n    if (this.signInResolver) {\n      response.backstageIdentity = await this.signInResolver(\n        {\n          result,\n          profile,\n        },\n        context,\n      );\n    }\n\n    return response;\n  }\n\n  private getUserPhoto(accessToken: string): Promise<string | undefined> {\n    return new Promise(resolve => {\n      fetch('https://graph.microsoft.com/v1.0/me/photos/48x48/$value', {\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n        },\n      })\n        .then(response => response.arrayBuffer())\n        .then(arrayBuffer => {\n          const imageUrl = `data:image/jpeg;base64,${Buffer.from(\n            arrayBuffer,\n          ).toString('base64')}`;\n          resolve(imageUrl);\n        })\n        .catch(error => {\n          this.logger.warn(\n            `Could not retrieve user profile photo from Microsoft Graph API: ${error}`,\n          );\n          // User profile photo is optional, ignore errors and resolve undefined\n          resolve(undefined);\n        });\n    });\n  }\n}\n\nexport const microsoftEmailSignInResolver: SignInResolver<OAuthResult> = async (\n  info,\n  ctx,\n) => {\n  const { profile } = info;\n\n  if (!profile.email) {\n    throw new Error('Microsoft profile contained no email');\n  }\n\n  const entity = await ctx.catalogIdentityClient.findUser({\n    annotations: {\n      'microsoft.com/email': profile.email,\n    },\n  });\n\n  const claims = getEntityClaims(entity);\n  const token = await ctx.tokenIssuer.issueToken({ claims });\n\n  return { id: entity.metadata.name, entity, token };\n};\n\nexport const microsoftDefaultSignInResolver: SignInResolver<\n  OAuthResult\n> = async (info, ctx) => {\n  const { profile } = info;\n\n  if (!profile.email) {\n    throw new Error('Profile contained no email');\n  }\n\n  const userId = profile.email.split('@')[0];\n\n  const entityRef = stringifyEntityRef({\n    kind: 'User',\n    namespace: DEFAULT_NAMESPACE,\n    name: userId,\n  });\n\n  const token = await ctx.tokenIssuer.issueToken({\n    claims: {\n      sub: entityRef,\n      ent: [entityRef],\n    },\n  });\n\n  return { id: userId, token };\n};\n\nexport type MicrosoftProviderOptions = {\n  /**\n   * The profile transformation function used to verify and convert the auth response\n   * into the profile that will be presented to the user.\n   */\n  authHandler?: AuthHandler<OAuthResult>;\n\n  /**\n   * Configure sign-in for this provider, without it the provider can not be used to sign users in.\n   */\n  signIn?: {\n    /**\n     * Maps an auth result to a Backstage identity for the user.\n     */\n    resolver?: SignInResolver<OAuthResult>;\n  };\n};\n\nexport const createMicrosoftProvider = (\n  options?: MicrosoftProviderOptions,\n): AuthProviderFactory => {\n  return ({\n    providerId,\n    globalConfig,\n    config,\n    tokenIssuer,\n    tokenManager,\n    catalogApi,\n    logger,\n  }) =>\n    OAuthEnvironmentHandler.mapConfig(config, envConfig => {\n      const clientId = envConfig.getString('clientId');\n      const clientSecret = envConfig.getString('clientSecret');\n      const tenantId = envConfig.getString('tenantId');\n\n      const customCallbackUrl = envConfig.getOptionalString('callbackUrl');\n      const callbackUrl =\n        customCallbackUrl ||\n        `${globalConfig.baseUrl}/${providerId}/handler/frame`;\n      const authorizationUrl = `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/authorize`;\n      const tokenUrl = `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`;\n\n      const catalogIdentityClient = new CatalogIdentityClient({\n        catalogApi,\n        tokenManager,\n      });\n\n      const authHandler: AuthHandler<OAuthResult> = options?.authHandler\n        ? options.authHandler\n        : async ({ fullProfile, params }) => ({\n            profile: makeProfileInfo(fullProfile, params.id_token),\n          });\n\n      const signInResolverFn =\n        options?.signIn?.resolver ?? microsoftDefaultSignInResolver;\n\n      const signInResolver: SignInResolver<OAuthResult> = info =>\n        signInResolverFn(info, {\n          catalogIdentityClient,\n          tokenIssuer,\n          logger,\n        });\n\n      const provider = new MicrosoftAuthProvider({\n        clientId,\n        clientSecret,\n        callbackUrl,\n        authorizationUrl,\n        tokenUrl,\n        authHandler,\n        signInResolver,\n        catalogIdentityClient,\n        logger,\n        tokenIssuer,\n      });\n\n      return OAuthAdapter.fromConfig(globalConfig, provider, {\n        disableRefresh: false,\n        providerId,\n        tokenIssuer,\n        callbackUrl,\n      });\n    });\n};\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DEFAULT_NAMESPACE,\n  stringifyEntityRef,\n} from '@backstage/catalog-model';\nimport express from 'express';\nimport passport from 'passport';\nimport { Strategy as OAuth2Strategy } from 'passport-oauth2';\nimport {\n  encodeState,\n  OAuthAdapter,\n  OAuthEnvironmentHandler,\n  OAuthHandlers,\n  OAuthProviderOptions,\n  OAuthRefreshRequest,\n  OAuthResponse,\n  OAuthResult,\n  OAuthStartRequest,\n} from '../../lib/oauth';\nimport {\n  executeFetchUserProfileStrategy,\n  executeFrameHandlerStrategy,\n  executeRedirectStrategy,\n  executeRefreshTokenStrategy,\n  makeProfileInfo,\n  PassportDoneCallback,\n} from '../../lib/passport';\nimport {\n  AuthHandler,\n  AuthProviderFactory,\n  RedirectInfo,\n  SignInResolver,\n} from '../types';\nimport { CatalogIdentityClient } from '../../lib/catalog';\nimport { TokenIssuer } from '../../identity';\nimport { Logger } from 'winston';\n\ntype PrivateInfo = {\n  refreshToken: string;\n};\n\nexport type OAuth2AuthProviderOptions = OAuthProviderOptions & {\n  signInResolver?: SignInResolver<OAuthResult>;\n  authHandler: AuthHandler<OAuthResult>;\n  tokenIssuer: TokenIssuer;\n  catalogIdentityClient: CatalogIdentityClient;\n  authorizationUrl: string;\n  tokenUrl: string;\n  scope?: string;\n  logger: Logger;\n  includeBasicAuth?: boolean;\n};\n\nexport class OAuth2AuthProvider implements OAuthHandlers {\n  private readonly _strategy: OAuth2Strategy;\n  private readonly signInResolver?: SignInResolver<OAuthResult>;\n  private readonly authHandler: AuthHandler<OAuthResult>;\n  private readonly tokenIssuer: TokenIssuer;\n  private readonly catalogIdentityClient: CatalogIdentityClient;\n  private readonly logger: Logger;\n\n  constructor(options: OAuth2AuthProviderOptions) {\n    this.signInResolver = options.signInResolver;\n    this.authHandler = options.authHandler;\n    this.tokenIssuer = options.tokenIssuer;\n    this.catalogIdentityClient = options.catalogIdentityClient;\n    this.logger = options.logger;\n\n    this._strategy = new OAuth2Strategy(\n      {\n        clientID: options.clientId,\n        clientSecret: options.clientSecret,\n        callbackURL: options.callbackUrl,\n        authorizationURL: options.authorizationUrl,\n        tokenURL: options.tokenUrl,\n        passReqToCallback: false as true,\n        scope: options.scope,\n        customHeaders: options.includeBasicAuth\n          ? {\n              Authorization: `Basic ${this.encodeClientCredentials(\n                options.clientId,\n                options.clientSecret,\n              )}`,\n            }\n          : undefined,\n      },\n      (\n        accessToken: any,\n        refreshToken: any,\n        params: any,\n        fullProfile: passport.Profile,\n        done: PassportDoneCallback<OAuthResult, PrivateInfo>,\n      ) => {\n        done(\n          undefined,\n          {\n            fullProfile,\n            accessToken,\n            refreshToken,\n            params,\n          },\n          {\n            refreshToken,\n          },\n        );\n      },\n    );\n  }\n\n  async start(req: OAuthStartRequest): Promise<RedirectInfo> {\n    return await executeRedirectStrategy(req, this._strategy, {\n      accessType: 'offline',\n      prompt: 'consent',\n      scope: req.scope,\n      state: encodeState(req.state),\n    });\n  }\n\n  async handler(req: express.Request) {\n    const { result, privateInfo } = await executeFrameHandlerStrategy<\n      OAuthResult,\n      PrivateInfo\n    >(req, this._strategy);\n\n    return {\n      response: await this.handleResult(result),\n      refreshToken: privateInfo.refreshToken,\n    };\n  }\n\n  async refresh(req: OAuthRefreshRequest) {\n    const refreshTokenResponse = await executeRefreshTokenStrategy(\n      this._strategy,\n      req.refreshToken,\n      req.scope,\n    );\n    const { accessToken, params, refreshToken } = refreshTokenResponse;\n\n    const fullProfile = await executeFetchUserProfileStrategy(\n      this._strategy,\n      accessToken,\n    );\n\n    return {\n      response: await this.handleResult({\n        fullProfile,\n        params,\n        accessToken,\n      }),\n      refreshToken,\n    };\n  }\n\n  private async handleResult(result: OAuthResult) {\n    const context = {\n      logger: this.logger,\n      catalogIdentityClient: this.catalogIdentityClient,\n      tokenIssuer: this.tokenIssuer,\n    };\n    const { profile } = await this.authHandler(result, context);\n\n    const response: OAuthResponse = {\n      providerInfo: {\n        idToken: result.params.id_token,\n        accessToken: result.accessToken,\n        scope: result.params.scope,\n        expiresInSeconds: result.params.expires_in,\n      },\n      profile,\n    };\n\n    if (this.signInResolver) {\n      response.backstageIdentity = await this.signInResolver(\n        {\n          result,\n          profile,\n        },\n        context,\n      );\n    }\n\n    return response;\n  }\n\n  encodeClientCredentials(clientID: string, clientSecret: string): string {\n    return Buffer.from(`${clientID}:${clientSecret}`).toString('base64');\n  }\n}\n\nexport const oAuth2DefaultSignInResolver: SignInResolver<OAuthResult> = async (\n  info,\n  ctx,\n) => {\n  const { profile } = info;\n\n  if (!profile.email) {\n    throw new Error('Profile contained no email');\n  }\n\n  const userId = profile.email.split('@')[0];\n\n  const entityRef = stringifyEntityRef({\n    kind: 'User',\n    namespace: DEFAULT_NAMESPACE,\n    name: userId,\n  });\n\n  const token = await ctx.tokenIssuer.issueToken({\n    claims: {\n      sub: entityRef,\n      ent: [entityRef],\n    },\n  });\n\n  return { id: userId, token };\n};\n\nexport type OAuth2ProviderOptions = {\n  authHandler?: AuthHandler<OAuthResult>;\n\n  signIn?: {\n    resolver?: SignInResolver<OAuthResult>;\n  };\n};\n\nexport const createOAuth2Provider = (\n  options?: OAuth2ProviderOptions,\n): AuthProviderFactory => {\n  return ({\n    providerId,\n    globalConfig,\n    config,\n    tokenIssuer,\n    tokenManager,\n    catalogApi,\n    logger,\n  }) =>\n    OAuthEnvironmentHandler.mapConfig(config, envConfig => {\n      const clientId = envConfig.getString('clientId');\n      const clientSecret = envConfig.getString('clientSecret');\n      const customCallbackUrl = envConfig.getOptionalString('callbackUrl');\n      const callbackUrl =\n        customCallbackUrl ||\n        `${globalConfig.baseUrl}/${providerId}/handler/frame`;\n      const authorizationUrl = envConfig.getString('authorizationUrl');\n      const tokenUrl = envConfig.getString('tokenUrl');\n      const scope = envConfig.getOptionalString('scope');\n      const includeBasicAuth = envConfig.getOptionalBoolean('includeBasicAuth');\n      const disableRefresh =\n        envConfig.getOptionalBoolean('disableRefresh') ?? false;\n\n      const catalogIdentityClient = new CatalogIdentityClient({\n        catalogApi,\n        tokenManager,\n      });\n\n      const authHandler: AuthHandler<OAuthResult> = options?.authHandler\n        ? options.authHandler\n        : async ({ fullProfile, params }) => ({\n            profile: makeProfileInfo(fullProfile, params.id_token),\n          });\n\n      const signInResolverFn =\n        options?.signIn?.resolver ?? oAuth2DefaultSignInResolver;\n\n      const signInResolver: SignInResolver<OAuthResult> = info =>\n        signInResolverFn(info, {\n          catalogIdentityClient,\n          tokenIssuer,\n          logger,\n        });\n\n      const provider = new OAuth2AuthProvider({\n        clientId,\n        clientSecret,\n        tokenIssuer,\n        catalogIdentityClient,\n        callbackUrl,\n        signInResolver,\n        authHandler,\n        authorizationUrl,\n        tokenUrl,\n        scope,\n        logger,\n        includeBasicAuth,\n      });\n\n      return OAuthAdapter.fromConfig(globalConfig, provider, {\n        disableRefresh,\n        providerId,\n        tokenIssuer,\n        callbackUrl,\n      });\n    });\n};\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport express from 'express';\nimport { Logger } from 'winston';\nimport { AuthenticationError } from '@backstage/errors';\nimport { getBearerTokenFromAuthorizationHeader } from '@backstage/plugin-auth-node';\nimport {\n  AuthHandler,\n  SignInResolver,\n  AuthProviderFactory,\n  AuthProviderRouteHandlers,\n  AuthResponse,\n} from '../types';\nimport { CatalogIdentityClient } from '../../lib/catalog';\nimport { JWT } from 'jose';\nimport { TokenIssuer } from '../../identity/types';\nimport { prepareBackstageIdentityResponse } from '../prepareBackstageIdentityResponse';\n\nexport const OAUTH2_PROXY_JWT_HEADER = 'X-OAUTH2-PROXY-ID-TOKEN';\n\n/**\n * JWT header extraction result, containing the raw value and the parsed JWT\n * payload.\n *\n * @public\n */\nexport type OAuth2ProxyResult<JWTPayload> = {\n  /**\n   * Parsed and decoded JWT payload.\n   */\n  fullProfile: JWTPayload;\n\n  /**\n   * Raw JWT token\n   */\n  accessToken: string;\n};\n\n/**\n * Options for the oauth2-proxy provider factory\n *\n * @public\n */\nexport type Oauth2ProxyProviderOptions<JWTPayload> = {\n  /**\n   * Configure an auth handler to generate a profile for the user.\n   */\n  authHandler: AuthHandler<OAuth2ProxyResult<JWTPayload>>;\n\n  /**\n   * Configure sign-in for this provider, without it the provider can not be used to sign users in.\n   */\n  signIn: {\n    /**\n     * Maps an auth result to a Backstage identity for the user.\n     */\n    resolver: SignInResolver<OAuth2ProxyResult<JWTPayload>>;\n  };\n};\n\ninterface Options<JWTPayload> {\n  logger: Logger;\n  signInResolver: SignInResolver<OAuth2ProxyResult<JWTPayload>>;\n  authHandler: AuthHandler<OAuth2ProxyResult<JWTPayload>>;\n  tokenIssuer: TokenIssuer;\n  catalogIdentityClient: CatalogIdentityClient;\n}\n\nexport class Oauth2ProxyAuthProvider<JWTPayload>\n  implements AuthProviderRouteHandlers\n{\n  private readonly logger: Logger;\n  private readonly catalogIdentityClient: CatalogIdentityClient;\n  private readonly signInResolver: SignInResolver<\n    OAuth2ProxyResult<JWTPayload>\n  >;\n  private readonly authHandler: AuthHandler<OAuth2ProxyResult<JWTPayload>>;\n  private readonly tokenIssuer: TokenIssuer;\n\n  constructor(options: Options<JWTPayload>) {\n    this.catalogIdentityClient = options.catalogIdentityClient;\n    this.logger = options.logger;\n    this.tokenIssuer = options.tokenIssuer;\n    this.signInResolver = options.signInResolver;\n    this.authHandler = options.authHandler;\n  }\n\n  frameHandler(): Promise<void> {\n    return Promise.resolve(undefined);\n  }\n\n  async refresh(req: express.Request, res: express.Response): Promise<void> {\n    try {\n      const result = this.getResult(req);\n\n      const response = await this.handleResult(result);\n\n      res.json(response);\n    } catch (e) {\n      this.logger.error(\n        `Exception occurred during ${OAUTH2_PROXY_JWT_HEADER} refresh`,\n        e,\n      );\n      res.status(401);\n      res.end();\n    }\n  }\n\n  start(): Promise<void> {\n    return Promise.resolve(undefined);\n  }\n\n  private async handleResult(\n    result: OAuth2ProxyResult<JWTPayload>,\n  ): Promise<AuthResponse<{ accessToken: string }>> {\n    const ctx = {\n      logger: this.logger,\n      tokenIssuer: this.tokenIssuer,\n      catalogIdentityClient: this.catalogIdentityClient,\n    };\n\n    const { profile } = await this.authHandler(result, ctx);\n\n    const backstageSignInResult = await this.signInResolver(\n      {\n        result,\n        profile,\n      },\n      ctx,\n    );\n\n    return {\n      providerInfo: {\n        accessToken: result.accessToken,\n      },\n      backstageIdentity: prepareBackstageIdentityResponse(\n        backstageSignInResult,\n      ),\n      profile,\n    };\n  }\n\n  private getResult(req: express.Request): OAuth2ProxyResult<JWTPayload> {\n    const authHeader = req.header(OAUTH2_PROXY_JWT_HEADER);\n    const jwt = getBearerTokenFromAuthorizationHeader(authHeader);\n\n    if (!jwt) {\n      throw new AuthenticationError(\n        `Missing or in incorrect format - Oauth2Proxy OIDC header: ${OAUTH2_PROXY_JWT_HEADER}`,\n      );\n    }\n\n    const decodedJWT = JWT.decode(jwt) as unknown as JWTPayload;\n\n    return {\n      fullProfile: decodedJWT,\n      accessToken: jwt,\n    };\n  }\n}\n\n/**\n * Factory function for oauth2-proxy auth provider\n *\n * @public\n */\nexport const createOauth2ProxyProvider =\n  <JWTPayload>(\n    options: Oauth2ProxyProviderOptions<JWTPayload>,\n  ): AuthProviderFactory =>\n  ({ catalogApi, logger, tokenIssuer, tokenManager }) => {\n    const signInResolver = options.signIn.resolver;\n    const authHandler = options.authHandler;\n    const catalogIdentityClient = new CatalogIdentityClient({\n      catalogApi,\n      tokenManager,\n    });\n    return new Oauth2ProxyAuthProvider<JWTPayload>({\n      logger,\n      signInResolver,\n      authHandler,\n      tokenIssuer,\n      catalogIdentityClient,\n    });\n  };\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DEFAULT_NAMESPACE,\n  stringifyEntityRef,\n} from '@backstage/catalog-model';\nimport express from 'express';\nimport {\n  Client,\n  Issuer,\n  Strategy as OidcStrategy,\n  TokenSet,\n  UserinfoResponse,\n} from 'openid-client';\nimport {\n  encodeState,\n  OAuthAdapter,\n  OAuthEnvironmentHandler,\n  OAuthHandlers,\n  OAuthProviderOptions,\n  OAuthRefreshRequest,\n  OAuthResponse,\n  OAuthStartRequest,\n} from '../../lib/oauth';\nimport {\n  executeFrameHandlerStrategy,\n  executeRedirectStrategy,\n  PassportDoneCallback,\n} from '../../lib/passport';\nimport {\n  AuthHandler,\n  AuthProviderFactory,\n  RedirectInfo,\n  SignInResolver,\n} from '../types';\nimport { CatalogIdentityClient } from '../../lib/catalog';\nimport { TokenIssuer } from '../../identity';\nimport { Logger } from 'winston';\n\ntype PrivateInfo = {\n  refreshToken?: string;\n};\n\ntype OidcImpl = {\n  strategy: OidcStrategy<UserinfoResponse, Client>;\n  client: Client;\n};\n\n/**\n * authentication result for the OIDC which includes the token set and user information (a profile response sent by OIDC server)\n * @public\n */\nexport type OidcAuthResult = {\n  tokenset: TokenSet;\n  userinfo: UserinfoResponse;\n};\n\nexport type Options = OAuthProviderOptions & {\n  metadataUrl: string;\n  scope?: string;\n  prompt?: string;\n  tokenSignedResponseAlg?: string;\n  signInResolver?: SignInResolver<OidcAuthResult>;\n  authHandler: AuthHandler<OidcAuthResult>;\n  tokenIssuer: TokenIssuer;\n  catalogIdentityClient: CatalogIdentityClient;\n  logger: Logger;\n};\n\nexport class OidcAuthProvider implements OAuthHandlers {\n  private readonly implementation: Promise<OidcImpl>;\n  private readonly scope?: string;\n  private readonly prompt?: string;\n\n  private readonly signInResolver?: SignInResolver<OidcAuthResult>;\n  private readonly authHandler: AuthHandler<OidcAuthResult>;\n  private readonly tokenIssuer: TokenIssuer;\n  private readonly catalogIdentityClient: CatalogIdentityClient;\n  private readonly logger: Logger;\n\n  constructor(options: Options) {\n    this.implementation = this.setupStrategy(options);\n    this.scope = options.scope;\n    this.prompt = options.prompt;\n    this.signInResolver = options.signInResolver;\n    this.authHandler = options.authHandler;\n    this.tokenIssuer = options.tokenIssuer;\n    this.catalogIdentityClient = options.catalogIdentityClient;\n    this.logger = options.logger;\n  }\n\n  async start(req: OAuthStartRequest): Promise<RedirectInfo> {\n    const { strategy } = await this.implementation;\n    const options: Record<string, string> = {\n      scope: req.scope || this.scope || 'openid profile email',\n      state: encodeState(req.state),\n    };\n    const prompt = this.prompt || 'none';\n    if (prompt !== 'auto') {\n      options.prompt = prompt;\n    }\n    return await executeRedirectStrategy(req, strategy, options);\n  }\n\n  async handler(req: express.Request) {\n    const { strategy } = await this.implementation;\n    const { result, privateInfo } = await executeFrameHandlerStrategy<\n      OidcAuthResult,\n      PrivateInfo\n    >(req, strategy);\n\n    return {\n      response: await this.handleResult(result),\n      refreshToken: privateInfo.refreshToken,\n    };\n  }\n\n  async refresh(req: OAuthRefreshRequest) {\n    const { client } = await this.implementation;\n    const tokenset = await client.refresh(req.refreshToken);\n    if (!tokenset.access_token) {\n      throw new Error('Refresh failed');\n    }\n    const userinfo = await client.userinfo(tokenset.access_token);\n\n    return {\n      response: await this.handleResult({ tokenset, userinfo }),\n      refreshToken: tokenset.refresh_token,\n    };\n  }\n\n  private async setupStrategy(options: Options): Promise<OidcImpl> {\n    const issuer = await Issuer.discover(options.metadataUrl);\n    const client = new issuer.Client({\n      access_type: 'offline', // this option must be passed to provider to receive a refresh token\n      client_id: options.clientId,\n      client_secret: options.clientSecret,\n      redirect_uris: [options.callbackUrl],\n      response_types: ['code'],\n      id_token_signed_response_alg: options.tokenSignedResponseAlg || 'RS256',\n      scope: options.scope || '',\n    });\n\n    const strategy = new OidcStrategy(\n      {\n        client,\n        passReqToCallback: false as true,\n      },\n      (\n        tokenset: TokenSet,\n        userinfo: UserinfoResponse,\n        done: PassportDoneCallback<OidcAuthResult, PrivateInfo>,\n      ) => {\n        if (typeof done !== 'function') {\n          throw new Error(\n            'OIDC IdP must provide a userinfo_endpoint in the metadata response',\n          );\n        }\n        done(\n          undefined,\n          { tokenset, userinfo },\n          {\n            refreshToken: tokenset.refresh_token,\n          },\n        );\n      },\n    );\n    strategy.error = console.error;\n    return { strategy, client };\n  }\n\n  // Use this function to grab the user profile info from the token\n  // Then populate the profile with it\n  private async handleResult(result: OidcAuthResult): Promise<OAuthResponse> {\n    const context = {\n      logger: this.logger,\n      catalogIdentityClient: this.catalogIdentityClient,\n      tokenIssuer: this.tokenIssuer,\n    };\n    const { profile } = await this.authHandler(result, context);\n    const response: OAuthResponse = {\n      providerInfo: {\n        idToken: result.tokenset.id_token,\n        accessToken: result.tokenset.access_token!,\n        scope: result.tokenset.scope!,\n        expiresInSeconds: result.tokenset.expires_in,\n      },\n      profile,\n    };\n    if (this.signInResolver) {\n      response.backstageIdentity = await this.signInResolver(\n        {\n          result,\n          profile,\n        },\n        context,\n      );\n    }\n\n    return response;\n  }\n}\n\nexport const oidcDefaultSignInResolver: SignInResolver<OidcAuthResult> = async (\n  info,\n  ctx,\n) => {\n  const { profile } = info;\n\n  if (!profile.email) {\n    throw new Error('Profile contained no email');\n  }\n\n  const userId = profile.email.split('@')[0];\n\n  const entityRef = stringifyEntityRef({\n    kind: 'User',\n    namespace: DEFAULT_NAMESPACE,\n    name: userId,\n  });\n\n  const token = await ctx.tokenIssuer.issueToken({\n    claims: {\n      sub: entityRef,\n      ent: [entityRef],\n    },\n  });\n\n  return { id: userId, token };\n};\n\n/**\n * OIDC provider callback options. An auth handler and a sign in resolver\n * can be passed while creating a OIDC provider.\n *\n * authHandler : called after sign in was successful, a new object must be returned which includes a profile\n * signInResolver: called after sign in was successful, expects to return a new {@link @backstage/plugin-auth-node#BackstageSignInResult}\n *\n * Both options are optional. There is fallback for authHandler where the default handler expect an e-mail explicitly\n * otherwise it throws an error\n *\n * @public\n */\nexport type OidcProviderOptions = {\n  authHandler?: AuthHandler<OidcAuthResult>;\n\n  signIn?: {\n    resolver?: SignInResolver<OidcAuthResult>;\n  };\n};\n\nexport const createOidcProvider = (\n  options?: OidcProviderOptions,\n): AuthProviderFactory => {\n  return ({\n    providerId,\n    globalConfig,\n    config,\n    tokenIssuer,\n    tokenManager,\n    catalogApi,\n    logger,\n  }) =>\n    OAuthEnvironmentHandler.mapConfig(config, envConfig => {\n      const clientId = envConfig.getString('clientId');\n      const clientSecret = envConfig.getString('clientSecret');\n      const customCallbackUrl = envConfig.getOptionalString('callbackUrl');\n      const callbackUrl =\n        customCallbackUrl ||\n        `${globalConfig.baseUrl}/${providerId}/handler/frame`;\n      const metadataUrl = envConfig.getString('metadataUrl');\n      const tokenSignedResponseAlg = envConfig.getOptionalString(\n        'tokenSignedResponseAlg',\n      );\n      const scope = envConfig.getOptionalString('scope');\n      const prompt = envConfig.getOptionalString('prompt');\n      const catalogIdentityClient = new CatalogIdentityClient({\n        catalogApi,\n        tokenManager,\n      });\n\n      const authHandler: AuthHandler<OidcAuthResult> = options?.authHandler\n        ? options.authHandler\n        : async ({ userinfo }) => ({\n            profile: {\n              displayName: userinfo.name,\n              email: userinfo.email,\n              picture: userinfo.picture,\n            },\n          });\n      const signInResolverFn =\n        options?.signIn?.resolver ?? oidcDefaultSignInResolver;\n      const signInResolver: SignInResolver<OidcAuthResult> = info =>\n        signInResolverFn(info, {\n          catalogIdentityClient,\n          tokenIssuer,\n          logger,\n        });\n\n      const provider = new OidcAuthProvider({\n        clientId,\n        clientSecret,\n        callbackUrl,\n        tokenSignedResponseAlg,\n        metadataUrl,\n        scope,\n        prompt,\n        signInResolver,\n        authHandler,\n        logger,\n        tokenIssuer,\n        catalogIdentityClient,\n      });\n\n      return OAuthAdapter.fromConfig(globalConfig, provider, {\n        disableRefresh: false,\n        providerId,\n        tokenIssuer,\n        callbackUrl,\n      });\n    });\n};\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DEFAULT_NAMESPACE,\n  stringifyEntityRef,\n} from '@backstage/catalog-model';\nimport express from 'express';\nimport {\n  OAuthAdapter,\n  OAuthProviderOptions,\n  OAuthHandlers,\n  OAuthResponse,\n  OAuthEnvironmentHandler,\n  OAuthStartRequest,\n  encodeState,\n  OAuthRefreshRequest,\n  OAuthResult,\n} from '../../lib/oauth';\nimport { Strategy as OktaStrategy } from 'passport-okta-oauth';\nimport passport from 'passport';\nimport {\n  executeFrameHandlerStrategy,\n  executeRedirectStrategy,\n  executeRefreshTokenStrategy,\n  makeProfileInfo,\n  executeFetchUserProfileStrategy,\n  PassportDoneCallback,\n} from '../../lib/passport';\nimport {\n  AuthProviderFactory,\n  AuthHandler,\n  RedirectInfo,\n  SignInResolver,\n} from '../types';\nimport { StateStore } from 'passport-oauth2';\nimport { CatalogIdentityClient, getEntityClaims } from '../../lib/catalog';\nimport { TokenIssuer } from '../../identity';\nimport { Logger } from 'winston';\n\ntype PrivateInfo = {\n  refreshToken: string;\n};\n\nexport type OktaAuthProviderOptions = OAuthProviderOptions & {\n  audience: string;\n  signInResolver?: SignInResolver<OAuthResult>;\n  authHandler: AuthHandler<OAuthResult>;\n  tokenIssuer: TokenIssuer;\n  catalogIdentityClient: CatalogIdentityClient;\n  logger: Logger;\n};\n\nexport class OktaAuthProvider implements OAuthHandlers {\n  private readonly _strategy: any;\n  private readonly _signInResolver?: SignInResolver<OAuthResult>;\n  private readonly _authHandler: AuthHandler<OAuthResult>;\n  private readonly _tokenIssuer: TokenIssuer;\n  private readonly _catalogIdentityClient: CatalogIdentityClient;\n  private readonly _logger: Logger;\n\n  /**\n   * Due to passport-okta-oauth forcing options.state = true,\n   * passport-oauth2 requires express-session to be installed\n   * so that the 'state' parameter of the oauth2 flow can be stored.\n   * This implementation of StateStore matches the NullStore found within\n   * passport-oauth2, which is the StateStore implementation used when options.state = false,\n   * allowing us to avoid using express-session in order to integrate with Okta.\n   */\n  private _store: StateStore = {\n    store(_req: express.Request, cb: any) {\n      cb(null, null);\n    },\n    verify(_req: express.Request, _state: string, cb: any) {\n      cb(null, true);\n    },\n  };\n\n  constructor(options: OktaAuthProviderOptions) {\n    this._signInResolver = options.signInResolver;\n    this._authHandler = options.authHandler;\n    this._tokenIssuer = options.tokenIssuer;\n    this._catalogIdentityClient = options.catalogIdentityClient;\n    this._logger = options.logger;\n\n    this._strategy = new OktaStrategy(\n      {\n        clientID: options.clientId,\n        clientSecret: options.clientSecret,\n        callbackURL: options.callbackUrl,\n        audience: options.audience,\n        passReqToCallback: false as true,\n        store: this._store,\n        response_type: 'code',\n      },\n      (\n        accessToken: any,\n        refreshToken: any,\n        params: any,\n        fullProfile: passport.Profile,\n        done: PassportDoneCallback<OAuthResult, PrivateInfo>,\n      ) => {\n        done(\n          undefined,\n          {\n            accessToken,\n            refreshToken,\n            params,\n            fullProfile,\n          },\n          {\n            refreshToken,\n          },\n        );\n      },\n    );\n  }\n\n  async start(req: OAuthStartRequest): Promise<RedirectInfo> {\n    return await executeRedirectStrategy(req, this._strategy, {\n      accessType: 'offline',\n      prompt: 'consent',\n      scope: req.scope,\n      state: encodeState(req.state),\n    });\n  }\n\n  async handler(req: express.Request) {\n    const { result, privateInfo } = await executeFrameHandlerStrategy<\n      OAuthResult,\n      PrivateInfo\n    >(req, this._strategy);\n\n    return {\n      response: await this.handleResult(result),\n      refreshToken: privateInfo.refreshToken,\n    };\n  }\n\n  async refresh(req: OAuthRefreshRequest) {\n    const { accessToken, refreshToken, params } =\n      await executeRefreshTokenStrategy(\n        this._strategy,\n        req.refreshToken,\n        req.scope,\n      );\n\n    const fullProfile = await executeFetchUserProfileStrategy(\n      this._strategy,\n      accessToken,\n    );\n\n    return {\n      response: await this.handleResult({\n        fullProfile,\n        params,\n        accessToken,\n      }),\n      refreshToken,\n    };\n  }\n\n  private async handleResult(result: OAuthResult) {\n    const context = {\n      logger: this._logger,\n      catalogIdentityClient: this._catalogIdentityClient,\n      tokenIssuer: this._tokenIssuer,\n    };\n    const { profile } = await this._authHandler(result, context);\n\n    const response: OAuthResponse = {\n      providerInfo: {\n        idToken: result.params.id_token,\n        accessToken: result.accessToken,\n        scope: result.params.scope,\n        expiresInSeconds: result.params.expires_in,\n      },\n      profile,\n    };\n\n    if (this._signInResolver) {\n      response.backstageIdentity = await this._signInResolver(\n        {\n          result,\n          profile,\n        },\n        context,\n      );\n    }\n\n    return response;\n  }\n}\n\nexport const oktaEmailSignInResolver: SignInResolver<OAuthResult> = async (\n  info,\n  ctx,\n) => {\n  const { profile } = info;\n\n  if (!profile.email) {\n    throw new Error('Okta profile contained no email');\n  }\n\n  const entity = await ctx.catalogIdentityClient.findUser({\n    annotations: {\n      'okta.com/email': profile.email,\n    },\n  });\n\n  const claims = getEntityClaims(entity);\n  const token = await ctx.tokenIssuer.issueToken({ claims });\n\n  return { id: entity.metadata.name, entity, token };\n};\n\nexport const oktaDefaultSignInResolver: SignInResolver<OAuthResult> = async (\n  info,\n  ctx,\n) => {\n  const { profile } = info;\n\n  if (!profile.email) {\n    throw new Error('Okta profile contained no email');\n  }\n\n  // TODO(Rugvip): Hardcoded to the local part of the email for now\n  const userId = profile.email.split('@')[0];\n\n  const entityRef = stringifyEntityRef({\n    kind: 'User',\n    namespace: DEFAULT_NAMESPACE,\n    name: userId,\n  });\n\n  const token = await ctx.tokenIssuer.issueToken({\n    claims: {\n      sub: entityRef,\n      ent: [entityRef],\n    },\n  });\n\n  return { id: userId, token };\n};\n\nexport type OktaProviderOptions = {\n  /**\n   * The profile transformation function used to verify and convert the auth response\n   * into the profile that will be presented to the user.\n   */\n  authHandler?: AuthHandler<OAuthResult>;\n\n  /**\n   * Configure sign-in for this provider, without it the provider can not be used to sign users in.\n   */\n  signIn?: {\n    /**\n     * Maps an auth result to a Backstage identity for the user.\n     */\n    resolver?: SignInResolver<OAuthResult>;\n  };\n};\n\nexport const createOktaProvider = (\n  _options?: OktaProviderOptions,\n): AuthProviderFactory => {\n  return ({\n    providerId,\n    globalConfig,\n    config,\n    tokenIssuer,\n    tokenManager,\n    catalogApi,\n    logger,\n  }) =>\n    OAuthEnvironmentHandler.mapConfig(config, envConfig => {\n      const clientId = envConfig.getString('clientId');\n      const clientSecret = envConfig.getString('clientSecret');\n      const audience = envConfig.getString('audience');\n      const customCallbackUrl = envConfig.getOptionalString('callbackUrl');\n      const callbackUrl =\n        customCallbackUrl ||\n        `${globalConfig.baseUrl}/${providerId}/handler/frame`;\n\n      // This is a safe assumption as `passport-okta-oauth` uses the audience\n      // as the base for building the authorization, token, and user info URLs.\n      // https://github.com/fischerdan/passport-okta-oauth/blob/ea9ac42d/lib/passport-okta-oauth/oauth2.js#L12-L14\n      if (!audience.startsWith('https://')) {\n        throw new Error(\"URL for 'audience' must start with 'https://'.\");\n      }\n\n      const catalogIdentityClient = new CatalogIdentityClient({\n        catalogApi,\n        tokenManager,\n      });\n\n      const authHandler: AuthHandler<OAuthResult> = _options?.authHandler\n        ? _options.authHandler\n        : async ({ fullProfile, params }) => ({\n            profile: makeProfileInfo(fullProfile, params.id_token),\n          });\n\n      const signInResolverFn =\n        _options?.signIn?.resolver ?? oktaDefaultSignInResolver;\n\n      const signInResolver: SignInResolver<OAuthResult> = info =>\n        signInResolverFn(info, {\n          catalogIdentityClient,\n          tokenIssuer,\n          logger,\n        });\n\n      const provider = new OktaAuthProvider({\n        audience,\n        clientId,\n        clientSecret,\n        callbackUrl,\n        authHandler,\n        signInResolver,\n        tokenIssuer,\n        catalogIdentityClient,\n        logger,\n      });\n\n      return OAuthAdapter.fromConfig(globalConfig, provider, {\n        disableRefresh: false,\n        providerId,\n        tokenIssuer,\n        callbackUrl,\n      });\n    });\n};\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Strategy as OneLoginStrategy } from 'passport-onelogin-oauth';\nimport express from 'express';\nimport {\n  OAuthAdapter,\n  OAuthProviderOptions,\n  OAuthHandlers,\n  OAuthResponse,\n  OAuthEnvironmentHandler,\n  OAuthStartRequest,\n  encodeState,\n  OAuthRefreshRequest,\n  OAuthResult,\n} from '../../lib/oauth';\nimport passport from 'passport';\nimport {\n  executeFrameHandlerStrategy,\n  executeRedirectStrategy,\n  executeRefreshTokenStrategy,\n  makeProfileInfo,\n  executeFetchUserProfileStrategy,\n  PassportDoneCallback,\n} from '../../lib/passport';\nimport {\n  RedirectInfo,\n  AuthProviderFactory,\n  AuthHandler,\n  SignInResolver,\n} from '../types';\nimport { CatalogIdentityClient } from '../../lib/catalog';\nimport { Logger } from 'winston';\nimport { TokenIssuer } from '../../identity';\n\ntype PrivateInfo = {\n  refreshToken: string;\n};\n\nexport type Options = OAuthProviderOptions & {\n  issuer: string;\n  signInResolver?: SignInResolver<OAuthResult>;\n  authHandler: AuthHandler<OAuthResult>;\n  tokenIssuer: TokenIssuer;\n  catalogIdentityClient: CatalogIdentityClient;\n  logger: Logger;\n};\n\nexport class OneLoginProvider implements OAuthHandlers {\n  private readonly _strategy: any;\n  private readonly signInResolver?: SignInResolver<OAuthResult>;\n  private readonly authHandler: AuthHandler<OAuthResult>;\n  private readonly tokenIssuer: TokenIssuer;\n  private readonly catalogIdentityClient: CatalogIdentityClient;\n  private readonly logger: Logger;\n\n  constructor(options: Options) {\n    this.signInResolver = options.signInResolver;\n    this.authHandler = options.authHandler;\n    this.tokenIssuer = options.tokenIssuer;\n    this.catalogIdentityClient = options.catalogIdentityClient;\n    this.logger = options.logger;\n    this._strategy = new OneLoginStrategy(\n      {\n        issuer: options.issuer,\n        clientID: options.clientId,\n        clientSecret: options.clientSecret,\n        callbackURL: options.callbackUrl,\n        passReqToCallback: false as true,\n      },\n      (\n        accessToken: any,\n        refreshToken: any,\n        params: any,\n        fullProfile: passport.Profile,\n        done: PassportDoneCallback<OAuthResult, PrivateInfo>,\n      ) => {\n        done(\n          undefined,\n          {\n            accessToken,\n            refreshToken,\n            params,\n            fullProfile,\n          },\n          {\n            refreshToken,\n          },\n        );\n      },\n    );\n  }\n  async start(req: OAuthStartRequest): Promise<RedirectInfo> {\n    return await executeRedirectStrategy(req, this._strategy, {\n      accessType: 'offline',\n      prompt: 'consent',\n      scope: 'openid',\n      state: encodeState(req.state),\n    });\n  }\n\n  async handler(req: express.Request) {\n    const { result, privateInfo } = await executeFrameHandlerStrategy<\n      OAuthResult,\n      PrivateInfo\n    >(req, this._strategy);\n\n    return {\n      response: await this.handleResult(result),\n      refreshToken: privateInfo.refreshToken,\n    };\n  }\n\n  async refresh(req: OAuthRefreshRequest) {\n    const { accessToken, refreshToken, params } =\n      await executeRefreshTokenStrategy(\n        this._strategy,\n        req.refreshToken,\n        req.scope,\n      );\n\n    const fullProfile = await executeFetchUserProfileStrategy(\n      this._strategy,\n      accessToken,\n    );\n\n    return {\n      response: await this.handleResult({\n        fullProfile,\n        params,\n        accessToken,\n      }),\n      refreshToken,\n    };\n  }\n\n  private async handleResult(result: OAuthResult) {\n    const context = {\n      logger: this.logger,\n      catalogIdentityClient: this.catalogIdentityClient,\n      tokenIssuer: this.tokenIssuer,\n    };\n    const { profile } = await this.authHandler(result, context);\n\n    const response: OAuthResponse = {\n      providerInfo: {\n        idToken: result.params.id_token,\n        accessToken: result.accessToken,\n        scope: result.params.scope,\n        expiresInSeconds: result.params.expires_in,\n      },\n      profile,\n    };\n\n    if (this.signInResolver) {\n      response.backstageIdentity = await this.signInResolver(\n        {\n          result,\n          profile,\n        },\n        context,\n      );\n    }\n\n    return response;\n  }\n}\n\nconst defaultSignInResolver: SignInResolver<OAuthResult> = async info => {\n  const { profile } = info;\n\n  if (!profile.email) {\n    throw new Error('OIDC profile contained no email');\n  }\n\n  const id = profile.email.split('@')[0];\n\n  return { id, token: '' };\n};\n\n/** @public */\nexport type OneLoginProviderOptions = {\n  /**\n   * The profile transformation function used to verify and convert the auth response\n   * into the profile that will be presented to the user.\n   */\n  authHandler?: AuthHandler<OAuthResult>;\n\n  /**\n   * Configure sign-in for this provider, without it the provider can not be used to sign users in.\n   */\n  signIn?: {\n    /**\n     * Maps an auth result to a Backstage identity for the user.\n     */\n    resolver: SignInResolver<OAuthResult>;\n  };\n};\n\n/** @public */\nexport const createOneLoginProvider = (\n  options?: OneLoginProviderOptions,\n): AuthProviderFactory => {\n  return ({\n    providerId,\n    globalConfig,\n    config,\n    tokenIssuer,\n    tokenManager,\n    catalogApi,\n    logger,\n  }) =>\n    OAuthEnvironmentHandler.mapConfig(config, envConfig => {\n      const clientId = envConfig.getString('clientId');\n      const clientSecret = envConfig.getString('clientSecret');\n      const issuer = envConfig.getString('issuer');\n      const customCallbackUrl = envConfig.getOptionalString('callbackUrl');\n      const callbackUrl =\n        customCallbackUrl ||\n        `${globalConfig.baseUrl}/${providerId}/handler/frame`;\n\n      const catalogIdentityClient = new CatalogIdentityClient({\n        catalogApi,\n        tokenManager,\n      });\n\n      const authHandler: AuthHandler<OAuthResult> = options?.authHandler\n        ? options.authHandler\n        : async ({ fullProfile, params }) => ({\n            profile: makeProfileInfo(fullProfile, params.id_token),\n          });\n\n      const signInResolver = options?.signIn?.resolver ?? defaultSignInResolver;\n\n      const provider = new OneLoginProvider({\n        clientId,\n        clientSecret,\n        callbackUrl,\n        issuer,\n        authHandler,\n        signInResolver,\n        tokenIssuer,\n        catalogIdentityClient,\n        logger,\n      });\n\n      return OAuthAdapter.fromConfig(globalConfig, provider, {\n        disableRefresh: false,\n        providerId,\n        tokenIssuer,\n        callbackUrl,\n      });\n    });\n};\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DEFAULT_NAMESPACE,\n  stringifyEntityRef,\n} from '@backstage/catalog-model';\nimport express from 'express';\nimport { SamlConfig } from 'passport-saml/lib/passport-saml/types';\nimport {\n  Strategy as SamlStrategy,\n  Profile as SamlProfile,\n  VerifyWithoutRequest,\n} from 'passport-saml';\nimport {\n  executeFrameHandlerStrategy,\n  executeRedirectStrategy,\n  PassportDoneCallback,\n} from '../../lib/passport';\nimport {\n  AuthProviderRouteHandlers,\n  AuthProviderFactory,\n  AuthHandler,\n  SignInResolver,\n  AuthResponse,\n} from '../types';\nimport { postMessageResponse } from '../../lib/flow';\nimport { TokenIssuer } from '../../identity/types';\nimport { isError } from '@backstage/errors';\nimport { CatalogIdentityClient } from '../../lib/catalog';\nimport { Logger } from 'winston';\nimport { prepareBackstageIdentityResponse } from '../prepareBackstageIdentityResponse';\n\n/** @public */\nexport type SamlAuthResult = {\n  fullProfile: any;\n};\n\ntype Options = SamlConfig & {\n  signInResolver?: SignInResolver<SamlAuthResult>;\n  authHandler: AuthHandler<SamlAuthResult>;\n  tokenIssuer: TokenIssuer;\n  catalogIdentityClient: CatalogIdentityClient;\n  logger: Logger;\n  appUrl: string;\n};\n\nexport class SamlAuthProvider implements AuthProviderRouteHandlers {\n  private readonly strategy: SamlStrategy;\n  private readonly signInResolver?: SignInResolver<SamlAuthResult>;\n  private readonly authHandler: AuthHandler<SamlAuthResult>;\n  private readonly tokenIssuer: TokenIssuer;\n  private readonly catalogIdentityClient: CatalogIdentityClient;\n  private readonly logger: Logger;\n  private readonly appUrl: string;\n\n  constructor(options: Options) {\n    this.appUrl = options.appUrl;\n    this.signInResolver = options.signInResolver;\n    this.authHandler = options.authHandler;\n    this.tokenIssuer = options.tokenIssuer;\n    this.catalogIdentityClient = options.catalogIdentityClient;\n    this.logger = options.logger;\n    this.strategy = new SamlStrategy({ ...options }, ((\n      fullProfile: SamlProfile,\n      done: PassportDoneCallback<SamlAuthResult>,\n    ) => {\n      // TODO: There's plenty more validation and profile handling to do here,\n      //       this provider is currently only intended to validate the provider pattern\n      //       for non-oauth auth flows.\n      // TODO: This flow doesn't issue an identity token that can be used to validate\n      //       the identity of the user in other backends, which we need in some form.\n      done(undefined, { fullProfile });\n    }) as VerifyWithoutRequest);\n  }\n\n  async start(req: express.Request, res: express.Response): Promise<void> {\n    const { url } = await executeRedirectStrategy(req, this.strategy, {});\n    res.redirect(url);\n  }\n\n  async frameHandler(\n    req: express.Request,\n    res: express.Response,\n  ): Promise<void> {\n    try {\n      const context = {\n        logger: this.logger,\n        catalogIdentityClient: this.catalogIdentityClient,\n        tokenIssuer: this.tokenIssuer,\n      };\n\n      const { result } = await executeFrameHandlerStrategy<SamlAuthResult>(\n        req,\n        this.strategy,\n      );\n\n      const { profile } = await this.authHandler(result, context);\n\n      const response: AuthResponse<{}> = {\n        profile,\n        providerInfo: {},\n      };\n\n      if (this.signInResolver) {\n        const signInResponse = await this.signInResolver(\n          {\n            result,\n            profile,\n          },\n          context,\n        );\n\n        response.backstageIdentity =\n          prepareBackstageIdentityResponse(signInResponse);\n      }\n\n      return postMessageResponse(res, this.appUrl, {\n        type: 'authorization_response',\n        response,\n      });\n    } catch (error) {\n      const { name, message } = isError(error)\n        ? error\n        : new Error('Encountered invalid error'); // Being a bit safe and not forwarding the bad value\n      return postMessageResponse(res, this.appUrl, {\n        type: 'authorization_response',\n        error: { name, message },\n      });\n    }\n  }\n\n  async logout(_req: express.Request, res: express.Response): Promise<void> {\n    res.end();\n  }\n}\n\nconst samlDefaultSignInResolver: SignInResolver<SamlAuthResult> = async (\n  info,\n  ctx,\n) => {\n  const id = info.result.fullProfile.nameID;\n\n  const entityRef = stringifyEntityRef({\n    kind: 'User',\n    namespace: DEFAULT_NAMESPACE,\n    name: id,\n  });\n\n  const token = await ctx.tokenIssuer.issueToken({\n    claims: {\n      sub: entityRef,\n      ent: [entityRef],\n    },\n  });\n\n  return { id, token };\n};\n\ntype SignatureAlgorithm = 'sha1' | 'sha256' | 'sha512';\n\n/** @public */\nexport type SamlProviderOptions = {\n  /**\n   * The profile transformation function used to verify and convert the auth response\n   * into the profile that will be presented to the user.\n   */\n  authHandler?: AuthHandler<SamlAuthResult>;\n\n  /**\n   * Configure sign-in for this provider, without it the provider can not be used to sign users in.\n   */\n  signIn?: {\n    /**\n     * Maps an auth result to a Backstage identity for the user.\n     */\n    resolver?: SignInResolver<SamlAuthResult>;\n  };\n};\n\n/** @public */\nexport const createSamlProvider = (\n  options?: SamlProviderOptions,\n): AuthProviderFactory => {\n  return ({\n    providerId,\n    globalConfig,\n    config,\n    tokenIssuer,\n    tokenManager,\n    catalogApi,\n    logger,\n  }) => {\n    const catalogIdentityClient = new CatalogIdentityClient({\n      catalogApi,\n      tokenManager,\n    });\n\n    const authHandler: AuthHandler<SamlAuthResult> = options?.authHandler\n      ? options.authHandler\n      : async ({ fullProfile }) => ({\n          profile: {\n            email: fullProfile.email,\n            displayName: fullProfile.displayName,\n          },\n        });\n\n    const signInResolverFn =\n      options?.signIn?.resolver ?? samlDefaultSignInResolver;\n\n    const signInResolver: SignInResolver<SamlAuthResult> = info =>\n      signInResolverFn(info, {\n        catalogIdentityClient,\n        tokenIssuer,\n        logger,\n      });\n\n    return new SamlAuthProvider({\n      callbackUrl: `${globalConfig.baseUrl}/${providerId}/handler/frame`,\n      entryPoint: config.getString('entryPoint'),\n      logoutUrl: config.getOptionalString('logoutUrl'),\n      audience: config.getOptionalString('audience'),\n      issuer: config.getString('issuer'),\n      cert: config.getString('cert'),\n      privateKey: config.getOptionalString('privateKey'),\n      authnContext: config.getOptionalStringArray('authnContext'),\n      identifierFormat: config.getOptionalString('identifierFormat'),\n      decryptionPvk: config.getOptionalString('decryptionPvk'),\n      signatureAlgorithm: config.getOptionalString('signatureAlgorithm') as\n        | SignatureAlgorithm\n        | undefined,\n      digestAlgorithm: config.getOptionalString('digestAlgorithm'),\n      acceptedClockSkewMs: config.getOptionalNumber('acceptedClockSkewMs'),\n\n      tokenIssuer,\n      appUrl: globalConfig.appUrl,\n      authHandler,\n      signInResolver,\n      logger,\n      catalogIdentityClient,\n    });\n  };\n};\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JsonValue } from '@backstage/types';\nimport { AuthHandler, AuthResponse, SignInResolver } from '../types';\n\n/**\n * The header name used by the IAP.\n */\nexport const IAP_JWT_HEADER = 'x-goog-iap-jwt-assertion';\n\n/**\n * The data extracted from an IAP token.\n *\n * @public\n */\nexport type GcpIapTokenInfo = {\n  /**\n   * The unique, stable identifier for the user.\n   */\n  sub: string;\n  /**\n   * User email address.\n   */\n  email: string;\n  /**\n   * Other fields.\n   */\n  [key: string]: JsonValue;\n};\n\n/**\n * The result of the initial auth challenge. This is the input to the auth\n * callbacks.\n *\n * @public\n */\nexport type GcpIapResult = {\n  /**\n   * The data extracted from the IAP token header.\n   */\n  iapToken: GcpIapTokenInfo;\n};\n\n/**\n * The provider info to return to the frontend.\n */\nexport type GcpIapProviderInfo = {\n  /**\n   * The data extracted from the IAP token header.\n   */\n  iapToken: GcpIapTokenInfo;\n};\n\n/**\n * The shape of the response to return to callers.\n */\nexport type GcpIapResponse = AuthResponse<GcpIapProviderInfo>;\n\n/**\n * Options for {@link createGcpIapProvider}.\n *\n * @public\n */\nexport type GcpIapProviderOptions = {\n  /**\n   * The profile transformation function used to verify and convert the auth\n   * response into the profile that will be presented to the user. The default\n   * implementation just provides the authenticated email that the IAP\n   * presented.\n   */\n  authHandler?: AuthHandler<GcpIapResult>;\n\n  /**\n   * Configures sign-in for this provider.\n   */\n  signIn: {\n    /**\n     * Maps an auth result to a Backstage identity for the user.\n     */\n    resolver: SignInResolver<GcpIapResult>;\n  };\n};\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AuthenticationError } from '@backstage/errors';\nimport { OAuth2Client, TokenPayload } from 'google-auth-library';\nimport { AuthHandler } from '../types';\nimport { GcpIapResult, IAP_JWT_HEADER } from './types';\n\nexport function createTokenValidator(\n  audience: string,\n  mockClient?: OAuth2Client,\n): (token: string) => Promise<TokenPayload> {\n  const client = mockClient ?? new OAuth2Client();\n\n  return async function tokenValidator(token) {\n    // TODO(freben): Rate limit the public key reads. It may be sensible to\n    // cache these for some reasonable time rather than asking for the public\n    // keys on every single sign-in. But since the rate of events here is so\n    // slow, I decided to keep it simple for now.\n    const response = await client.getIapPublicKeys();\n    const ticket = await client.verifySignedJwtWithCertsAsync(\n      token,\n      response.pubkeys,\n      audience,\n      ['https://cloud.google.com/iap'],\n    );\n\n    const payload = ticket.getPayload();\n    if (!payload) {\n      throw new TypeError('Token had no payload');\n    }\n\n    return payload;\n  };\n}\n\nexport async function parseRequestToken(\n  jwtToken: unknown,\n  tokenValidator: (token: string) => Promise<TokenPayload>,\n): Promise<GcpIapResult> {\n  if (typeof jwtToken !== 'string' || !jwtToken) {\n    throw new AuthenticationError(\n      `Missing Google IAP header: ${IAP_JWT_HEADER}`,\n    );\n  }\n\n  let payload: TokenPayload;\n  try {\n    payload = await tokenValidator(jwtToken);\n  } catch (e) {\n    throw new AuthenticationError(`Google IAP token verification failed, ${e}`);\n  }\n\n  if (!payload.sub || !payload.email) {\n    throw new AuthenticationError(\n      'Google IAP token payload is missing sub and/or email claim',\n    );\n  }\n\n  return {\n    iapToken: {\n      ...payload,\n      sub: payload.sub,\n      email: payload.email,\n    },\n  };\n}\n\nexport const defaultAuthHandler: AuthHandler<GcpIapResult> = async ({\n  iapToken,\n}) => ({ profile: { email: iapToken.email } });\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport express from 'express';\nimport { TokenPayload } from 'google-auth-library';\nimport { Logger } from 'winston';\nimport { TokenIssuer } from '../../identity/types';\nimport { CatalogIdentityClient } from '../../lib/catalog';\nimport { prepareBackstageIdentityResponse } from '../prepareBackstageIdentityResponse';\nimport {\n  AuthHandler,\n  AuthProviderFactory,\n  AuthProviderRouteHandlers,\n  SignInResolver,\n} from '../types';\nimport {\n  createTokenValidator,\n  defaultAuthHandler,\n  parseRequestToken,\n} from './helpers';\nimport {\n  GcpIapProviderOptions,\n  GcpIapResponse,\n  GcpIapResult,\n  IAP_JWT_HEADER,\n} from './types';\n\nexport class GcpIapProvider implements AuthProviderRouteHandlers {\n  private readonly authHandler: AuthHandler<GcpIapResult>;\n  private readonly signInResolver: SignInResolver<GcpIapResult>;\n  private readonly tokenValidator: (token: string) => Promise<TokenPayload>;\n  private readonly tokenIssuer: TokenIssuer;\n  private readonly catalogIdentityClient: CatalogIdentityClient;\n  private readonly logger: Logger;\n\n  constructor(options: {\n    authHandler: AuthHandler<GcpIapResult>;\n    signInResolver: SignInResolver<GcpIapResult>;\n    tokenValidator: (token: string) => Promise<TokenPayload>;\n    tokenIssuer: TokenIssuer;\n    catalogIdentityClient: CatalogIdentityClient;\n    logger: Logger;\n  }) {\n    this.authHandler = options.authHandler;\n    this.signInResolver = options.signInResolver;\n    this.tokenValidator = options.tokenValidator;\n    this.tokenIssuer = options.tokenIssuer;\n    this.catalogIdentityClient = options.catalogIdentityClient;\n    this.logger = options.logger;\n  }\n\n  async start() {}\n\n  async frameHandler() {}\n\n  async refresh(req: express.Request, res: express.Response): Promise<void> {\n    const result = await parseRequestToken(\n      req.header(IAP_JWT_HEADER),\n      this.tokenValidator,\n    );\n    const context = {\n      logger: this.logger,\n      catalogIdentityClient: this.catalogIdentityClient,\n      tokenIssuer: this.tokenIssuer,\n    };\n\n    const { profile } = await this.authHandler(result, context);\n\n    const backstageIdentity = await this.signInResolver(\n      { profile, result },\n      context,\n    );\n\n    const response: GcpIapResponse = {\n      providerInfo: { iapToken: result.iapToken },\n      profile,\n      backstageIdentity: prepareBackstageIdentityResponse(backstageIdentity),\n    };\n\n    res.json(response);\n  }\n}\n\n/**\n * Creates an auth provider for Google Identity-Aware Proxy.\n *\n * @public\n */\nexport function createGcpIapProvider(\n  options: GcpIapProviderOptions,\n): AuthProviderFactory {\n  return ({ config, tokenIssuer, catalogApi, logger, tokenManager }) => {\n    const audience = config.getString('audience');\n\n    const authHandler = options.authHandler ?? defaultAuthHandler;\n    const signInResolver = options.signIn.resolver;\n    const tokenValidator = createTokenValidator(audience);\n\n    const catalogIdentityClient = new CatalogIdentityClient({\n      catalogApi,\n      tokenManager,\n    });\n\n    return new GcpIapProvider({\n      authHandler,\n      signInResolver,\n      tokenValidator,\n      tokenIssuer,\n      catalogIdentityClient,\n      logger,\n    });\n  };\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createGithubProvider } from './github';\nimport { createGitlabProvider } from './gitlab';\nimport { createGoogleProvider } from './google';\nimport { createOAuth2Provider } from './oauth2';\nimport { createOidcProvider } from './oidc';\nimport { createOktaProvider } from './okta';\nimport { createSamlProvider } from './saml';\nimport { createAuth0Provider } from './auth0';\nimport { createMicrosoftProvider } from './microsoft';\nimport { createOneLoginProvider } from './onelogin';\nimport { AuthProviderFactory } from './types';\nimport { createAwsAlbProvider } from './aws-alb';\nimport { createBitbucketProvider } from './bitbucket';\nimport { createAtlassianProvider } from './atlassian';\n\nexport const factories: { [providerId: string]: AuthProviderFactory } = {\n  google: createGoogleProvider(),\n  github: createGithubProvider(),\n  gitlab: createGitlabProvider(),\n  saml: createSamlProvider(),\n  okta: createOktaProvider(),\n  auth0: createAuth0Provider(),\n  microsoft: createMicrosoftProvider(),\n  oauth2: createOAuth2Provider(),\n  oidc: createOidcProvider(),\n  onelogin: createOneLoginProvider(),\n  awsalb: createAwsAlbProvider(),\n  bitbucket: createBitbucketProvider(),\n  atlassian: createAtlassianProvider(),\n};\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Router from 'express-promise-router';\nimport { TokenIssuer } from './types';\n\nexport type Options = {\n  baseUrl: string;\n  tokenIssuer: TokenIssuer;\n};\n\nexport function createOidcRouter(options: Options) {\n  const { baseUrl, tokenIssuer } = options;\n\n  const router = Router();\n\n  const config = {\n    issuer: baseUrl,\n    token_endpoint: `${baseUrl}/v1/token`,\n    userinfo_endpoint: `${baseUrl}/v1/userinfo`,\n    jwks_uri: `${baseUrl}/.well-known/jwks.json`,\n    response_types_supported: ['id_token'],\n    subject_types_supported: ['public'],\n    id_token_signing_alg_values_supported: ['RS256'],\n    scopes_supported: ['openid'],\n    token_endpoint_auth_methods_supported: [],\n    claims_supported: ['sub'],\n    grant_types_supported: [],\n  };\n\n  router.get('/.well-known/openid-configuration', (_req, res) => {\n    res.json(config);\n  });\n\n  router.get('/.well-known/jwks.json', async (_req, res) => {\n    const { keys } = await tokenIssuer.listPublicKeys();\n    res.json({ keys });\n  });\n\n  router.get('/v1/token', (_req, res) => {\n    res.status(501).send('Not Implemented');\n  });\n\n  router.get('/v1/userinfo', (_req, res) => {\n    res.status(501).send('Not Implemented');\n  });\n\n  return router;\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TokenIssuer, TokenParams, KeyStore, AnyJWK } from './types';\nimport { JSONWebKey, JWK, JWS } from 'jose';\nimport { Logger } from 'winston';\nimport { v4 as uuid } from 'uuid';\nimport { DateTime } from 'luxon';\nimport { parseEntityRef } from '@backstage/catalog-model';\n\nconst MS_IN_S = 1000;\n\ntype Options = {\n  logger: Logger;\n  /** Value of the issuer claim in issued tokens */\n  issuer: string;\n  /** Key store used for storing signing keys */\n  keyStore: KeyStore;\n  /** Expiration time of signing keys in seconds */\n  keyDurationSeconds: number;\n};\n\n/**\n * A token issuer that is able to issue tokens in a distributed system\n * backed by a single database. Tokens are issued using lazily generated\n * signing keys, where each running instance of the auth service uses its own\n * signing key.\n *\n * The public parts of the keys are all stored in the shared key storage,\n * and any of the instances of the auth service will return the full list\n * of public keys that are currently in storage.\n *\n * Signing keys are automatically rotated at the same interval as the token\n * duration. Expired keys are kept in storage until there are no valid tokens\n * in circulation that could have been signed by that key.\n */\nexport class TokenFactory implements TokenIssuer {\n  private readonly issuer: string;\n  private readonly logger: Logger;\n  private readonly keyStore: KeyStore;\n  private readonly keyDurationSeconds: number;\n\n  private keyExpiry?: Date;\n  private privateKeyPromise?: Promise<JSONWebKey>;\n\n  constructor(options: Options) {\n    this.issuer = options.issuer;\n    this.logger = options.logger;\n    this.keyStore = options.keyStore;\n    this.keyDurationSeconds = options.keyDurationSeconds;\n  }\n\n  async issueToken(params: TokenParams): Promise<string> {\n    const key = await this.getKey();\n\n    const iss = this.issuer;\n    const sub = params.claims.sub;\n    const ent = params.claims.ent;\n    const aud = 'backstage';\n    const iat = Math.floor(Date.now() / MS_IN_S);\n    const exp = iat + this.keyDurationSeconds;\n\n    // Validate that the subject claim is a valid EntityRef\n    try {\n      parseEntityRef(sub);\n    } catch (error) {\n      throw new Error(\n        '\"sub\" claim provided by the auth resolver is not a valid EntityRef.',\n      );\n    }\n\n    this.logger.info(`Issuing token for ${sub}, with entities ${ent ?? []}`);\n\n    return JWS.sign({ iss, sub, aud, iat, exp, ent }, key, {\n      alg: key.alg,\n      kid: key.kid,\n    });\n  }\n\n  // This will be called by other services that want to verify ID tokens.\n  // It is important that it returns a list of all public keys that could\n  // have been used to sign tokens that have not yet expired.\n  async listPublicKeys(): Promise<{ keys: AnyJWK[] }> {\n    const { items: keys } = await this.keyStore.listKeys();\n\n    const validKeys = [];\n    const expiredKeys = [];\n\n    for (const key of keys) {\n      // Allow for a grace period of another full key duration before we remove the keys from the database\n      const expireAt = DateTime.fromJSDate(key.createdAt).plus({\n        seconds: 3 * this.keyDurationSeconds,\n      });\n      if (expireAt < DateTime.local()) {\n        expiredKeys.push(key);\n      } else {\n        validKeys.push(key);\n      }\n    }\n\n    // Lazily prune expired keys. This may cause duplicate removals if we have concurrent callers, but w/e\n    if (expiredKeys.length > 0) {\n      const kids = expiredKeys.map(({ key }) => key.kid);\n\n      this.logger.info(`Removing expired signing keys, '${kids.join(\"', '\")}'`);\n\n      // We don't await this, just let it run in the background\n      this.keyStore.removeKeys(kids).catch(error => {\n        this.logger.error(`Failed to remove expired keys, ${error}`);\n      });\n    }\n\n    // NOTE: we're currently only storing public keys, but if we start storing private keys we'd have to convert here\n    return { keys: validKeys.map(({ key }) => key) };\n  }\n\n  private async getKey(): Promise<JSONWebKey> {\n    // Make sure that we only generate one key at a time\n    if (this.privateKeyPromise) {\n      if (\n        this.keyExpiry &&\n        DateTime.fromJSDate(this.keyExpiry) > DateTime.local()\n      ) {\n        return this.privateKeyPromise;\n      }\n      this.logger.info(`Signing key has expired, generating new key`);\n      delete this.privateKeyPromise;\n    }\n\n    this.keyExpiry = DateTime.utc()\n      .plus({\n        seconds: this.keyDurationSeconds,\n      })\n      .toJSDate();\n    const promise = (async () => {\n      // This generates a new signing key to be used to sign tokens until the next key rotation\n      const key = await JWK.generate('EC', 'P-256', {\n        use: 'sig',\n        kid: uuid(),\n        alg: 'ES256',\n      });\n\n      // We're not allowed to use the key until it has been successfully stored\n      // TODO: some token verification implementations aggressively cache the list of keys, and\n      //       don't attempt to fetch new ones even if they encounter an unknown kid. Therefore we\n      //       may want to keep using the existing key for some period of time until we switch to\n      //       the new one. This also needs to be implemented cross-service though, meaning new services\n      //       that boot up need to be able to grab an existing key to use for signing.\n      this.logger.info(`Created new signing key ${key.kid}`);\n      await this.keyStore.addKey(key.toJWK(false) as unknown as AnyJWK);\n\n      // At this point we are allowed to start using the new key\n      return key as JSONWebKey;\n    })();\n\n    this.privateKeyPromise = promise;\n\n    try {\n      // If we fail to generate a new key, we need to clear the state so that\n      // the next caller will try to generate another key.\n      await promise;\n    } catch (error) {\n      this.logger.error(`Failed to generate new signing key, ${error}`);\n      delete this.keyExpiry;\n      delete this.privateKeyPromise;\n    }\n\n    return promise;\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { resolvePackagePath } from '@backstage/backend-common';\nimport { Knex } from 'knex';\nimport { DateTime } from 'luxon';\nimport { AnyJWK, KeyStore, StoredKey } from './types';\n\nconst migrationsDir = resolvePackagePath(\n  '@backstage/plugin-auth-backend',\n  'migrations',\n);\n\nconst TABLE = 'signing_keys';\n\ntype Row = {\n  created_at: Date; // row.created_at is a string after being returned from the database\n  kid: string;\n  key: string;\n};\n\ntype Options = {\n  database: Knex;\n};\n\nconst parseDate = (date: string | Date) => {\n  const parsedDate =\n    typeof date === 'string'\n      ? DateTime.fromSQL(date, { zone: 'UTC' })\n      : DateTime.fromJSDate(date);\n\n  if (!parsedDate.isValid) {\n    throw new Error(\n      `Failed to parse date, reason: ${parsedDate.invalidReason}, explanation: ${parsedDate.invalidExplanation}`,\n    );\n  }\n\n  return parsedDate.toJSDate();\n};\n\nexport class DatabaseKeyStore implements KeyStore {\n  static async create(options: Options): Promise<DatabaseKeyStore> {\n    const { database } = options;\n\n    await database.migrate.latest({\n      directory: migrationsDir,\n    });\n\n    return new DatabaseKeyStore(options);\n  }\n\n  private readonly database: Knex;\n\n  private constructor(options: Options) {\n    this.database = options.database;\n  }\n\n  async addKey(key: AnyJWK): Promise<void> {\n    await this.database<Row>(TABLE).insert({\n      kid: key.kid,\n      key: JSON.stringify(key),\n    });\n  }\n\n  async listKeys(): Promise<{ items: StoredKey[] }> {\n    const rows = await this.database<Row>(TABLE).select();\n\n    return {\n      items: rows.map(row => ({\n        key: JSON.parse(row.key),\n        createdAt: parseDate(row.created_at),\n      })),\n    };\n  }\n\n  async removeKeys(kids: string[]): Promise<void> {\n    await this.database(TABLE).delete().whereIn('kid', kids);\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { KeyStore, AnyJWK, StoredKey } from './types';\nimport { DateTime } from 'luxon';\n\nexport class MemoryKeyStore implements KeyStore {\n  private readonly keys = new Map<string, { createdAt: Date; key: string }>();\n\n  async addKey(key: AnyJWK): Promise<void> {\n    this.keys.set(key.kid, {\n      createdAt: DateTime.utc().toJSDate(),\n      key: JSON.stringify(key),\n    });\n  }\n\n  async removeKeys(kids: string[]): Promise<void> {\n    for (const kid of kids) {\n      this.keys.delete(kid);\n    }\n  }\n\n  async listKeys(): Promise<{ items: StoredKey[] }> {\n    return {\n      items: Array.from(this.keys).map(([, { createdAt, key: keyStr }]) => ({\n        createdAt,\n        key: JSON.parse(keyStr),\n      })),\n    };\n  }\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Logger } from 'winston';\nimport {\n  DocumentData,\n  Firestore,\n  QuerySnapshot,\n  Settings,\n  WriteResult,\n} from '@google-cloud/firestore';\n\nimport { AnyJWK, KeyStore, StoredKey } from './types';\n\nexport type FirestoreKeyStoreSettings = Settings & Options;\n\ntype Options = {\n  path?: string;\n  timeout?: number;\n};\n\nexport const DEFAULT_TIMEOUT_MS = 10000;\nexport const DEFAULT_DOCUMENT_PATH = 'sessions';\n\nexport class FirestoreKeyStore implements KeyStore {\n  static async create(\n    settings?: FirestoreKeyStoreSettings,\n  ): Promise<FirestoreKeyStore> {\n    const { path, timeout, ...firestoreSettings } = settings ?? {};\n    const database = new Firestore(firestoreSettings);\n\n    return new FirestoreKeyStore(\n      database,\n      path ?? DEFAULT_DOCUMENT_PATH,\n      timeout ?? DEFAULT_TIMEOUT_MS,\n    );\n  }\n\n  private constructor(\n    private readonly database: Firestore,\n    private readonly path: string,\n    private readonly timeout: number,\n  ) {}\n\n  static async verifyConnection(\n    keyStore: FirestoreKeyStore,\n    logger?: Logger,\n  ): Promise<void> {\n    try {\n      await keyStore.verify();\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'development') {\n        throw new Error(\n          `Failed to connect to database: ${(error as Error).message}`,\n        );\n      }\n      logger?.warn(\n        `Failed to connect to database: ${(error as Error).message}`,\n      );\n    }\n  }\n\n  async addKey(key: AnyJWK): Promise<void> {\n    await this.withTimeout<WriteResult>(\n      this.database\n        .collection(this.path)\n        .doc(key.kid)\n        .set({\n          kid: key.kid,\n          key: JSON.stringify(key),\n        }),\n    );\n  }\n\n  async listKeys(): Promise<{ items: StoredKey[] }> {\n    const keys = await this.withTimeout<QuerySnapshot<DocumentData>>(\n      this.database.collection(this.path).get(),\n    );\n\n    return {\n      items: keys.docs.map(key => ({\n        key: key.data() as AnyJWK,\n        createdAt: key.createTime.toDate(),\n      })),\n    };\n  }\n\n  async removeKeys(kids: string[]): Promise<void> {\n    // This is probably really slow, but it's done async in the background\n    for (const kid of kids) {\n      await this.withTimeout<WriteResult>(\n        this.database.collection(this.path).doc(kid).delete(),\n      );\n    }\n\n    /**\n     * This could be achieved with batching but there's a couple of limitations with that:\n     *\n     * - A batched write can contain a maximum of 500 operations\n     *  https://firebase.google.com/docs/firestore/manage-data/transactions#batched-writes\n     *\n     * - The \"in\" operator can combine a maximum of 10 equality clauses\n     *  https://firebase.google.com/docs/firestore/query-data/queries#in_not-in_and_array-contains-any\n     *\n     * Example:\n     *\n     *  const batch = this.database.batch();\n     *  const docs = await this.database\n     *    .collection(this.path)\n     *    .where('kid', 'in', kids)\n     *    .get();\n     *  docs.forEach(doc => {\n     *    batch.delete(doc.ref);\n     *  });\n     *  await batch.commit();\n     *\n     */\n  }\n\n  /**\n   * Helper function to allow us to modify the timeout used when\n   * performing Firestore database operations.\n   *\n   * The reason for this is that it seems that there's no other\n   * practical solution to change the default timeout of 10mins\n   * that Firestore has.\n   *\n   */\n  private async withTimeout<T>(operation: Promise<T>): Promise<T> {\n    const timer = new Promise<never>((_, reject) =>\n      setTimeout(() => {\n        reject(new Error(`Operation timed out after ${this.timeout}ms`));\n      }, this.timeout),\n    );\n    return Promise.race<T>([operation, timer]);\n  }\n\n  /**\n   * Used to verify that the database is reachable.\n   */\n  private async verify(): Promise<void> {\n    await this.withTimeout(this.database.collection(this.path).limit(1).get());\n  }\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Logger } from 'winston';\nimport { pickBy } from 'lodash';\n\nimport { PluginDatabaseManager } from '@backstage/backend-common';\nimport { Config } from '@backstage/config';\n\nimport { DatabaseKeyStore } from './DatabaseKeyStore';\nimport { MemoryKeyStore } from './MemoryKeyStore';\nimport { FirestoreKeyStore } from './FirestoreKeyStore';\nimport { KeyStore } from './types';\n\ntype Options = {\n  logger?: Logger;\n  database?: PluginDatabaseManager;\n};\n\nexport class KeyStores {\n  /**\n   * Looks at the `auth.keyStore` section in the application configuration\n   * and returns a KeyStore store. Defaults to `database`\n   *\n   * @returns a KeyStore store\n   */\n  static async fromConfig(\n    config: Config,\n    options?: Options,\n  ): Promise<KeyStore> {\n    const { logger, database } = options ?? {};\n\n    const ks = config.getOptionalConfig('auth.keyStore');\n    const provider = ks?.getOptionalString('provider') ?? 'database';\n\n    logger?.info(`Configuring \"${provider}\" as KeyStore provider`);\n\n    if (provider === 'database') {\n      if (!database) {\n        throw new Error('This KeyStore provider requires a database');\n      }\n\n      return await DatabaseKeyStore.create({\n        database: await database.getClient(),\n      });\n    }\n\n    if (provider === 'memory') {\n      return new MemoryKeyStore();\n    }\n\n    if (provider === 'firestore') {\n      const settings = ks?.getConfig(provider);\n\n      const keyStore = await FirestoreKeyStore.create(\n        pickBy(\n          {\n            projectId: settings?.getOptionalString('projectId'),\n            keyFilename: settings?.getOptionalString('keyFilename'),\n            host: settings?.getOptionalString('host'),\n            port: settings?.getOptionalNumber('port'),\n            ssl: settings?.getOptionalBoolean('ssl'),\n            path: settings?.getOptionalString('path'),\n            timeout: settings?.getOptionalNumber('timeout'),\n          },\n          value => value !== undefined,\n        ),\n      );\n      await FirestoreKeyStore.verifyConnection(keyStore, logger);\n\n      return keyStore;\n    }\n\n    throw new Error(`Unknown KeyStore provider: ${provider}`);\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport express from 'express';\nimport Router from 'express-promise-router';\nimport cookieParser from 'cookie-parser';\nimport { Logger } from 'winston';\nimport {\n  defaultAuthProviderFactories,\n  AuthProviderFactory,\n} from '../providers';\nimport {\n  PluginDatabaseManager,\n  PluginEndpointDiscovery,\n  TokenManager,\n} from '@backstage/backend-common';\nimport { assertError, NotFoundError } from '@backstage/errors';\nimport { CatalogClient } from '@backstage/catalog-client';\nimport { Config } from '@backstage/config';\nimport { createOidcRouter, TokenFactory, KeyStores } from '../identity';\nimport session from 'express-session';\nimport passport from 'passport';\nimport { Minimatch } from 'minimatch';\n\ntype ProviderFactories = { [s: string]: AuthProviderFactory };\n\nexport interface RouterOptions {\n  logger: Logger;\n  database: PluginDatabaseManager;\n  config: Config;\n  discovery: PluginEndpointDiscovery;\n  tokenManager: TokenManager;\n  providerFactories?: ProviderFactories;\n}\n\nexport async function createRouter(\n  options: RouterOptions,\n): Promise<express.Router> {\n  const {\n    logger,\n    config,\n    discovery,\n    database,\n    tokenManager,\n    providerFactories,\n  } = options;\n  const router = Router();\n\n  const appUrl = config.getString('app.baseUrl');\n  const authUrl = await discovery.getExternalBaseUrl('auth');\n\n  const keyStore = await KeyStores.fromConfig(config, { logger, database });\n  const keyDurationSeconds = 3600;\n\n  const tokenIssuer = new TokenFactory({\n    issuer: authUrl,\n    keyStore,\n    keyDurationSeconds,\n    logger: logger.child({ component: 'token-factory' }),\n  });\n  const catalogApi = new CatalogClient({ discoveryApi: discovery });\n\n  const secret = config.getOptionalString('auth.session.secret');\n  if (secret) {\n    router.use(cookieParser(secret));\n    // TODO: Configure the server-side session storage.  The default MemoryStore is not designed for production\n    const enforceCookieSSL = authUrl.startsWith('https');\n    router.use(\n      session({\n        secret,\n        saveUninitialized: false,\n        resave: false,\n        cookie: { secure: enforceCookieSSL ? 'auto' : false },\n      }),\n    );\n    router.use(passport.initialize());\n    router.use(passport.session());\n  } else {\n    router.use(cookieParser());\n  }\n  router.use(express.urlencoded({ extended: false }));\n  router.use(express.json());\n\n  const allProviderFactories = {\n    ...defaultAuthProviderFactories,\n    ...providerFactories,\n  };\n  const providersConfig = config.getConfig('auth.providers');\n  const configuredProviders = providersConfig.keys();\n\n  const isOriginAllowed = createOriginFilter(config);\n\n  for (const [providerId, providerFactory] of Object.entries(\n    allProviderFactories,\n  )) {\n    if (configuredProviders.includes(providerId)) {\n      logger.info(`Configuring provider, ${providerId}`);\n      try {\n        const provider = providerFactory({\n          providerId,\n          globalConfig: {\n            baseUrl: authUrl,\n            appUrl,\n            isOriginAllowed,\n          },\n          config: providersConfig.getConfig(providerId),\n          logger,\n          tokenManager,\n          tokenIssuer,\n          discovery,\n          catalogApi,\n        });\n\n        const r = Router();\n\n        r.get('/start', provider.start.bind(provider));\n        r.get('/handler/frame', provider.frameHandler.bind(provider));\n        r.post('/handler/frame', provider.frameHandler.bind(provider));\n        if (provider.logout) {\n          r.post('/logout', provider.logout.bind(provider));\n        }\n        if (provider.refresh) {\n          r.get('/refresh', provider.refresh.bind(provider));\n        }\n\n        router.use(`/${providerId}`, r);\n      } catch (e) {\n        assertError(e);\n        if (process.env.NODE_ENV !== 'development') {\n          throw new Error(\n            `Failed to initialize ${providerId} auth provider, ${e.message}`,\n          );\n        }\n\n        logger.warn(`Skipping ${providerId} auth provider, ${e.message}`);\n\n        router.use(`/${providerId}`, () => {\n          // If the user added the provider under auth.providers but the clientId and clientSecret etc. were not found.\n          throw new NotFoundError(\n            `Auth provider registered for '${providerId}' is misconfigured. This could mean the configs under ` +\n              `auth.providers.${providerId} are missing or the environment variables used are not defined. ` +\n              `Check the auth backend plugin logs when the backend starts to see more details.`,\n          );\n        });\n      }\n    } else {\n      router.use(`/${providerId}`, () => {\n        throw new NotFoundError(\n          `No auth provider registered for '${providerId}'`,\n        );\n      });\n    }\n  }\n\n  router.use(\n    createOidcRouter({\n      tokenIssuer,\n      baseUrl: authUrl,\n    }),\n  );\n\n  router.use('/:provider/', req => {\n    const { provider } = req.params;\n    throw new NotFoundError(`Unknown auth provider '${provider}'`);\n  });\n\n  return router;\n}\n\nexport function createOriginFilter(\n  config: Config,\n): (origin: string) => boolean {\n  const appUrl = config.getString('app.baseUrl');\n  const { origin: appOrigin } = new URL(appUrl);\n\n  const allowedOrigins = config.getOptionalStringArray(\n    'auth.experimentalExtraAllowedOrigins',\n  );\n\n  const allowedOriginPatterns =\n    allowedOrigins?.map(\n      pattern => new Minimatch(pattern, { nocase: true, noglobstar: true }),\n    ) ?? [];\n\n  return origin => {\n    if (origin === appOrigin) {\n      return true;\n    }\n    return allowedOriginPatterns.some(pattern => pattern.match(origin));\n  };\n}\n"],"names":["OAuth2Strategy","InternalOAuthError","pickBy","InputError","NotFoundError","crypto","stringifyEntityRef","parseEntityRef","DEFAULT_NAMESPACE","URL","NotAllowedError","isError","AuthenticationError","jwtDecoder","ConflictError","RELATION_MEMBER_OF","defaultSignInResolver","NodeCache","JWT","fetch","BitbucketStrategy","GithubStrategy","GitlabStrategy","GoogleStrategy","MicrosoftStrategy","getBearerTokenFromAuthorizationHeader","Issuer","OidcStrategy","OktaStrategy","OneLoginStrategy","SamlStrategy","OAuth2Client","Router","JWS","DateTime","JWK","uuid","resolvePackagePath","Firestore","CatalogClient","cookieParser","session","passport","express","defaultAuthProviderFactories","Minimatch"],"mappings":"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"}